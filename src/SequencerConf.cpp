/*----- PROTECTED REGION ID(SequencerConf.cpp) ENABLED START -----*/
static const char *RcsId = "$Id: SequencerConf.cpp,v 1.7 2017-04-28 10:00:11 graziano Exp $";
//=============================================================================
//
// file :        SequencerConf.cpp
//
// description : C++ source for the SequencerConf and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               SequencerConf are implemented in this file.
//
// project :     Configurable Sequencer.
//
// $Author: graziano $
//
// $Revision: 1.7 $
// $Date: 2017-04-28 10:00:11 $
//
// SVN only:
// $HeadURL:  $
//
// CVS only:
// $Source: /home/cvsadm/cvsroot/fermi/servers/sequencerconf/src/SequencerConf.cpp,v $
// $Log: SequencerConf.cpp,v $
// Revision 1.7  2017-04-28 10:00:11  graziano
// fixed string equality
//
// Revision 1.6  2017-04-28 07:30:38  graziano
// fixed string
//
// Revision 1.5  2015-01-26 10:03:54  graziano
// fixed
//
// Revision 1.4  2013-12-17 08:55:58  graziano
// func_tango improvement
//
// Revision 1.3  2013-11-20 13:44:42  graziano
// development
//
// Revision 1.2  2013-11-19 14:58:56  graziano
// development
//
// Revision 1.1  2013-11-15 08:15:09  graziano
// first commit
//
//
//
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <SequencerConf.h>
#include <SequencerConfClass.h>
#include <math.h>
#include <stdint.h>
#include <algorithm>

#include "formula_grammar.h"

const char srvver[] = RELEASE;

std::map<parser_id, std::string> rule_names;  //only for log messages

/*----- PROTECTED REGION END -----*/


/**
 *	SequencerConf class description:
 *	
 */

//================================================================
//
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//----------------------------------------------------------------
//  State         |  Inherited (no method)
//  Status        |  Inherited (no method)
//================================================================

namespace SequencerConf_ns
{
	/*----- PROTECTED REGION ID(SequencerConf::namespace_starting) ENABLED START -----*/

	//	static initializations
bool compare_attr_index (attr_desc_t i,attr_desc_t j) { return (i.attr_index < j.attr_index); }

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::namespace_starting



//--------------------------------------------------------
/**
 *	Method      : SequencerConf::SequencerConf()
 *	Description : Constructors for a Tango device
 *	              implementing the class SequencerConf
 */
//--------------------------------------------------------
SequencerConf::SequencerConf(Tango::DeviceClass *cl, string &s)
 	: Tango::Device_4Impl(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(SequencerConf::constructor_1) ENABLED START -----*/

	init_device();

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::constructor_1
}
//--------------------------------------------------------
SequencerConf::SequencerConf(Tango::DeviceClass *cl, const char *s)
 	: Tango::Device_4Impl(cl, s)
{
	/*----- PROTECTED REGION ID(SequencerConf::constructor_2) ENABLED START -----*/

	init_device();

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::constructor_2
}
//--------------------------------------------------------
SequencerConf::SequencerConf(Tango::DeviceClass *cl, const char *s, const char *d)
 	: Tango::Device_4Impl(cl, s, d)
{
	/*----- PROTECTED REGION ID(SequencerConf::constructor_3) ENABLED START -----*/

	init_device();

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::constructor_3
}


//--------------------------------------------------------
/**
 *	Method      : SequencerConf::delete_device()()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void SequencerConf::delete_device()
{
	/*----- PROTECTED REGION ID(SequencerConf::delete_device) ENABLED START -----*/

	//	Delete device allocated objects
	DEBUG_STREAM << __FUNCTION__<<": entering..." << endl;

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::delete_device
	read_loop->abortflag = true;
	set_state(Tango::OFF);
	usleep(550000);

	delete[] attr_BoolScalarDyn_read;
	delete[] attr_BoolSpectrumDyn_read;
	delete[] attr_StringSpectrumDyn_read;
	delete[] attr_Version_read;
	delete [] attr_Log_read;
	delete [] attr_StepStatus_read;
	delete [] attr_StepError_read;
	delete [] attr_Step_read;
	delete [] attr_RemainingTime_read;
	delete [] attr_ElapsedTime_read;
	
	//delete proxies
	vector<remote_dev_t>::iterator it;
	for(it=remote_devices.begin(); it!=remote_devices.end(); it++)
	{
		try {
			it->remote_device->unsubscribe_event(it->eid);
			usleep(10000);
			delete it->remote_device;
		} catch(...)
		{}
	}

	//remote_devices and other maps/vectors
	remote_devices.clear();
	att_data.clear();
	att_value.clear();

}


//--------------------------------------------------------
/**
 *	Method      : SequencerConf::init_device()
 *	Description : //	will be called at device initialization.
 */
//--------------------------------------------------------
void SequencerConf::init_device()
{
	DEBUG_STREAM << "SequencerConf::init_device() create device " << device_name << endl;

	/*----- PROTECTED REGION ID(SequencerConf::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call
	set_state(Tango::INIT);
	created_attr = false;
	attr_index = 0;

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::init_device_before
	
	//	Get the device properties (if any) from database
	get_device_property();
	
	attr_BoolScalarDyn_read = new Tango::DevBoolean[1];
	attr_BoolSpectrumDyn_read = new Tango::DevBoolean[MAX_ATTR_SIZE];
	attr_StringSpectrumDyn_read = new Tango::DevString[MAX_ATTR_SIZE];
	attr_Version_read = new Tango::DevString[1];
	attr_Log_read = new Tango::DevString[3*MAX_ATTR_SIZE];
	attr_StepStatus_read = new Tango::DevString[1];
	attr_StepError_read = new Tango::DevString[1];
	attr_Step_read = new Tango::DevLong[1];
	attr_RemainingTime_read = new Tango::DevLong[1];
	attr_ElapsedTime_read = new Tango::DevLong[1];
	
	/*----- PROTECTED REGION ID(SequencerConf::init_device) ENABLED START -----*/

	//	Initialize device
	*attr_RemainingTime_read = 0;
	*attr_ElapsedTime_read = 0;
	clock_gettime(CLOCK_MONOTONIC,&start_time);
#if 0
	ecb.init(this);
#endif
	log_str_size = 0;
	for(int i=0; i<LOG_SIZE; i++)
	{
		attr_Log_read[i] = (char *)log_str[i];
	}
	attr_Version_read[0] = (char *)version_str;
	attr_StepStatus_read[0] = (char *)stepstatus_str;
	attr_StepError_read[0] = (char *)steperror_str;

    rule_names[formula_grammar::val_rID] = "ValReal";
    rule_names[formula_grammar::val_hID] = "ValHex";
    rule_names[formula_grammar::val_stID] = "ValStatus";
    rule_names[formula_grammar::event_ID] = "EventFather";
	rule_names[formula_grammar::nameID] = "EventName";
	rule_names[formula_grammar::indexID] = "EventIndex";
	rule_names[formula_grammar::funcID] = "Function";
	rule_names[formula_grammar::logical_exprID] = "LogicalE";
	rule_names[formula_grammar::bitwise_exprID] = "BitwiseE";
	rule_names[formula_grammar::equality_exprID] = "EqualityE";
	rule_names[formula_grammar::compare_exprID] = "CompareE";
	rule_names[formula_grammar::add_exprID] = "AddE";
	rule_names[formula_grammar::mult_exprID] = "MultE";
	rule_names[formula_grammar::expr_atomID] = "AtomicE";
	rule_names[formula_grammar::shift_exprID] = "ShiftE";
	rule_names[formula_grammar::unary_exprID] = "UnaryE";
	rule_names[formula_grammar::val_stringID] = "ValString";
	rule_names[formula_grammar::func_dualID] = "FuncDualE";
	rule_names[formula_grammar::logical_expr_parenID] = "LogicalEPAREN";
	rule_names[formula_grammar::cond_exprID] = "CondE";
	rule_names[formula_grammar::exprID] = "Expr";
	rule_names[formula_grammar::nonempty_exprID] = "NonEmptyExpr";
	rule_names[formula_grammar::func_tangoID] = "TangoFunc";
	rule_names[formula_grammar::val_sleepID] = "Sleep";
	rule_names[formula_grammar::func_gotoID] = "Goto";

	step = 0;
	*attr_Step_read = 0;

	read_loop = new readthread(this);
	read_loop->start();

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::init_device
}



//--------------------------------------------------------
/**
 *	Method      : SequencerConf::get_device_property()
 *	Description : //	Add your own code to initialize
 */
//--------------------------------------------------------
void SequencerConf::get_device_property()
{
	/*----- PROTECTED REGION ID(SequencerConf::get_device_property_before) ENABLED START -----*/

	//	Initialize property data members

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Attr_config_file"));
	dev_prop.push_back(Tango::DbDatum("Attr_config_prop"));
	dev_prop.push_back(Tango::DbDatum("Polling_period"));
	dev_prop.push_back(Tango::DbDatum("DefaultStepTimeout"));
	//dev_prop.push_back(Tango::DbDatum("Read_timeout"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on SequencerConfClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		SequencerConfClass	*ds_class =
			(static_cast<SequencerConfClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize Attr_config_file from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  attr_config_file;
		else {
			//	Try to initialize Attr_config_file from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  attr_config_file;
		}
		//	And try to extract Attr_config_file value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  attr_config_file;

		//	Try to initialize Attr_config_prop from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  attr_config_prop;
		else {
			//	Try to initialize Attr_config_prop from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  attr_config_prop;
		}
		//	And try to extract Attr_config_prop value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  attr_config_prop;

		//	Try to initialize Polling_period from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  polling_period;
		else {
			//	Try to initialize Polling_period from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  polling_period;
		}
		//	And try to extract Polling_period value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  polling_period;

		//	Try to initialize DefaultStepTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  defaultStepTimeout;
		else {
			//	Try to initialize DefaultStepTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  defaultStepTimeout;
		}
		//	And try to extract DefaultStepTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  defaultStepTimeout;
/*
		//	Try to initialize Read_timeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  read_timeout;
		else {
			//	Try to initialize Read_timeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  read_timeout;
		}
		//	And try to extract Read_timeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  read_timeout;
*/
	}
	/*----- PROTECTED REGION ID(SequencerConf::get_device_property_after) ENABLED START -----*/

	//	Check device property data members init

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::get_device_property_after

}

//--------------------------------------------------------
/**
 *	Method      : SequencerConf::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void SequencerConf::always_executed_hook()
{
	//INFO_STREAM << "SequencerConf::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(SequencerConf::always_executed_hook) ENABLED START -----*/

	//	code always executed before all requests


	/*----- PROTECTED REGION END -----*/	//	SequencerConf::always_executed_hook
}



//--------------------------------------------------------
/**
 *	Method      : SequencerConf::read_attr_hardware()
 *	Description : Hardware acquisition for attributes.
 */
//--------------------------------------------------------
void SequencerConf::read_attr_hardware(vector<long> &attr_list)
{
	//DEBUG_STREAM << "SequencerConf::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(SequencerConf::read_attr_hardware) ENABLED START -----*/

	//	Add your own code




	/*----- PROTECTED REGION END -----*/	//	SequencerConf::read_attr_hardware

}


//--------------------------------------------------------
/**
 *	Read BoolScalarDyn attribute
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void SequencerConf::read_BoolScalarDyn(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "SequencerConf::read_BoolScalarDyn(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SequencerConf::read_BoolScalarDyn) ENABLED START -----*/

	map<string,attr_val_t >::iterator it_val = att_value.find(attr.get_name());

	if(it_val == att_value.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}
#if 0
	map<string,vector<attr_desc_t> >::iterator it_attr = att_data.find(attr.get_name());

	if(it_attr == att_data.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}

	string attr_values;

	double res = 0.0;	//initialize to false
	try
	{
		res = eval_formula(it_attr->second[0].formula_tree, attr.get_name(), attr_values);
	}
	catch(string &err)
	{
		DEBUG_STREAM << __func__<<": error evaluating formula="<<err;
		Tango::Except::throw_exception(
						(const char*)"Error evaluating formula",
						(const char*)err.c_str(),
						(const char*)__func__, Tango::ERR);
	}

	it_val->second.val[ it_attr->second[0].attr_index ] = (res != 0.0);
	it_val->second.old_val[ it_attr->second[0].attr_index ] = (res != 0.0);
#endif
    //	Set the attribute value
    attr.set_value(&(it_val->second.val[0]));

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::read_BoolScalarDyn
}
//--------------------------------------------------------
/**
 *	Read BoolSpectrumDyn attribute
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Spectrum  max = 1000
 */
//--------------------------------------------------------
void SequencerConf::read_BoolSpectrumDyn(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "SequencerConf::read_BoolSpectrumDyn(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SequencerConf::read_BoolSpectrumDyn) ENABLED START -----*/

	//	Set the attribute value
#if 0
	map<string,attr_val_t >::iterator it_val = att_value.find(attr.get_name());

	if(it_val == att_value.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}

	map<string,attr_desc_t>::iterator it_attr = att_data.find(attr.get_name());

	if(it_attr == att_data.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}
#if 0
	for(vector<attr_desc_t>::iterator it_rem_attr = it_attr->second.begin(); it_rem_attr != it_attr->second.end(); it_rem_attr++)
	{
		DEBUG_STREAM << __FUNCTION__ << " looping " << it_rem_attr->formula;

		string attr_values;
		double res = 0.0;	//initialize to false
		try
		{
			res = eval_formula(it_rem_attr->formula_tree, attr.get_name(), attr_values);
		}
		catch(string &err)
		{
			INFO_STREAM << __func__<<": error evaluating formula="<<err;
			Tango::Except::throw_exception(
							(const char*)"Error evaluating formula",
							(const char*)err.c_str(),
							(const char*)__func__, Tango::ERR);
		}

		it_val->second.val[ it_rem_attr->attr_index ] = (res != 0.0);
		it_val->second.old_val[ it_rem_attr->attr_index ] = (res != 0.0);
	}
#endif
    //	Set the attribute value
    attr.set_value(&(it_val->second.val[0]), it_attr->second.size());
#endif
	/*----- PROTECTED REGION END -----*/	//	SequencerConf::read_BoolSpectrumDyn
}
//--------------------------------------------------------
/**
 *	Read StringSpectrumDyn attribute
 *	Description:
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum  max = 1000
 */
//--------------------------------------------------------
void SequencerConf::read_StringSpectrumDyn(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "SequencerConf::read_StringSpectrumDyn(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SequencerConf::read_StringSpectrumDyn) ENABLED START -----*/

	//	Set the attribute value


    //DEBUG_STREAM << __FUNCTION__ << " after set_value";
	/*----- PROTECTED REGION END -----*/	//	SequencerConf::read_BoolSpectrumDyn
}

//--------------------------------------------------------
/**
 *	Read DoubleScalarDyn attribute
 *	Description:
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SequencerConf::read_DoubleScalarDyn(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "SequencerConf::read_DoubleScalarDyn(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SequencerConf::read_DoubleScalarDyn) ENABLED START -----*/

	map<string,attr_val_t >::iterator it_val = att_value.find(attr.get_name());

	if(it_val == att_value.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}
#if 0
	map<string,vector<attr_desc_t> >::iterator it_attr = att_data.find(attr.get_name());

	if(it_attr == att_data.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}

	string attr_values;

	double res = 0.0;	//initialize to false
	try
	{
		res = eval_formula(it_attr->second[0].formula_tree, attr.get_name(), attr_values);
	}
	catch(string &err)
	{
		DEBUG_STREAM << __func__<<": error evaluating formula="<<err;
		Tango::Except::throw_exception(
						(const char*)"Error evaluating formula",
						(const char*)err.c_str(),
						(const char*)__func__, Tango::ERR);
	}

	it_val->second.val_d[ it_attr->second[0].attr_index ] = res;
	it_val->second.old_val_d[ it_attr->second[0].attr_index ] = res;
#endif

    //	Set the attribute value
    attr.set_value(&(it_val->second.val_d[0]));

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::read_DoubleScalarDyn
}
//--------------------------------------------------------
/**
 *	Read DoubleSpectrumDyn attribute
 *	Description:
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Spectrum  max = 1000
 */
//--------------------------------------------------------
void SequencerConf::read_DoubleSpectrumDyn(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SequencerConf::read_DoubleSpectrumDyn(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SequencerConf::read_DoubleSpectrumDyn) ENABLED START -----*/

	//	Set the attribute value
#if 0
	map<string,attr_val_t >::iterator it_val = att_value.find(attr.get_name());

	if(it_val == att_value.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}

	map<string,attr_desc_t>::iterator it_attr = att_data.find(attr.get_name());

	if(it_attr == att_data.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}
#if 0
	for(vector<attr_desc_t>::iterator it_rem_attr = it_attr->second.begin(); it_rem_attr != it_attr->second.end(); it_rem_attr++)
	{
		DEBUG_STREAM << __FUNCTION__ << " looping " << it_rem_attr->formula;

		string attr_values;
		double res = 0.0;	//initialize to false
		try
		{
			res = eval_formula(it_rem_attr->formula_tree, attr.get_name(), attr_values);
		}
		catch(string &err)
		{
			INFO_STREAM << __func__<<": error evaluating formula="<<err;
			Tango::Except::throw_exception(
							(const char*)"Error evaluating formula",
							(const char*)err.c_str(),
							(const char*)__func__, Tango::ERR);
		}

		it_val->second.val_d[ it_rem_attr->attr_index ] = res;
	}
#endif
    //	Set the attribute value
    attr.set_value(&(it_val->second.val_d[0]), it_attr->second.size());
#endif
	/*----- PROTECTED REGION END -----*/	//	SequencerConf::read_DoubleSpectrumDyn
}


//--------------------------------------------------------
/**
 *	Read LongScalarDyn attribute
 *	Description:
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SequencerConf::read_LongScalarDyn(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SequencerConf::read_LongScalarDyn(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SequencerConf::read_LongScalarDyn) ENABLED START -----*/

	map<string,attr_val_t >::iterator it_val = att_value.find(attr.get_name());

	if(it_val == att_value.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}
#if 0
	map<string,vector<attr_desc_t> >::iterator it_attr = att_data.find(attr.get_name());

	if(it_attr == att_data.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}

	string attr_values;

	double res = 0.0;	//initialize to false
	try
	{
		res = eval_formula(it_attr->second[0].formula_tree, attr.get_name(), attr_values);
	}
	catch(string &err)
	{
		DEBUG_STREAM << __func__<<": error evaluating formula="<<err;
		Tango::Except::throw_exception(
						(const char*)"Error evaluating formula",
						(const char*)err.c_str(),
						(const char*)__func__, Tango::ERR);
	}

	it_val->second.val_l[ it_attr->second[0].attr_index ] = (Tango::DevLong)res;
	it_val->second.old_val_l[ it_attr->second[0].attr_index ] = (Tango::DevLong)res;
#endif

    //	Set the attribute value
    attr.set_value(&(it_val->second.val_l[0]));

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::read_LongScalarDyn
}
//--------------------------------------------------------
/**
 *	Read LongSpectrumDyn attribute
 *	Description:
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Spectrum  max = 1000
 */
//--------------------------------------------------------
void SequencerConf::read_LongSpectrumDyn(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SequencerConf::read_LongSpectrumDyn(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SequencerConf::read_LongSpectrumDyn) ENABLED START -----*/

	//	Set the attribute value
#if 0
	map<string,attr_val_t >::iterator it_val = att_value.find(attr.get_name());

	if(it_val == att_value.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}

	map<string,vector<attr_desc_t> >::iterator it_attr = att_data.find(attr.get_name());

	if(it_attr == att_data.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}
#if 0
	for(vector<attr_desc_t>::iterator it_rem_attr = it_attr->second.begin(); it_rem_attr != it_attr->second.end(); it_rem_attr++)
	{
		DEBUG_STREAM << __FUNCTION__ << " looping " << it_rem_attr->formula;

		string attr_values;
		double res = 0.0;	//initialize to false
		try
		{
			res = eval_formula(it_rem_attr->formula_tree, attr.get_name(), attr_values);
		}
		catch(string &err)
		{
			INFO_STREAM << __func__<<": error evaluating formula="<<err;
			Tango::Except::throw_exception(
							(const char*)"Error evaluating formula",
							(const char*)err.c_str(),
							(const char*)__func__, Tango::ERR);
		}

		it_val->second.val_l[ it_rem_attr->attr_index ] = (Tango::DevLong)res;
	}
#endif
    //	Set the attribute value
    attr.set_value(&(it_val->second.val_l[0]), it_attr->second.size());
#endif
	/*----- PROTECTED REGION END -----*/	//	SequencerConf::read_LongSpectrumDyn
}

//--------------------------------------------------------
/**
 *	Read Version attribute
 *	Description:
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SequencerConf::read_Version(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "SequencerConf::read_BoolScalarDyn(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SequencerConf::read_BoolScalarDyn) ENABLED START -----*/

	string tmp(srvver);
	size_t pos = tmp.find("Name: ");
	tmp = tmp.substr(pos+strlen("Name: "));

	sprintf(version_str,"srv_ver:%s",tmp.c_str());

    //	Set the attribute value
    attr.set_value(attr_Version_read);

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::read_BoolScalarDyn
}

//--------------------------------------------------------
/**
 *	Read Log attribute
 *	Description:
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum  max = 1000
 */
//--------------------------------------------------------
void SequencerConf::read_Log(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "SequencerConf::read_Log(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SequencerConf::read_Log) ENABLED START -----*/

	//	Set the attribute value

	attr.set_value(attr_Log_read, log_str_size);

    //DEBUG_STREAM << __FUNCTION__ << " after set_value";
	/*----- PROTECTED REGION END -----*/	//	SequencerConf::read_Log
}

//--------------------------------------------------------
/**
 *	Read StepStatus attribute
 *	Description:
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SequencerConf::read_StepStatus(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "SequencerConf::read_StepStatus(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SequencerConf::read_StepStatus) ENABLED START -----*/

    //	Set the attribute value
    attr.set_value(attr_StepStatus_read);

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::read_StepStatus
}

//--------------------------------------------------------
/**
 *	Read StepError attribute
 *	Description:
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SequencerConf::read_StepError(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "SequencerConf::read_StepError(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SequencerConf::read_StepError) ENABLED START -----*/

    //	Set the attribute value
    attr.set_value(attr_StepError_read);

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::read_StepError
}

//--------------------------------------------------------
/**
 *	Read Step attribute
 *	Description:
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SequencerConf::read_Step(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "SequencerConf::read_Step(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SequencerConf::read_Step) ENABLED START -----*/

    //	Set the attribute value
    attr.set_value(attr_Step_read);

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::read_Step
}

//--------------------------------------------------------
/**
 *	Read RemainingTime attribute
 *	Description:
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SequencerConf::read_RemainingTime(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "SequencerConf::read_RemainingTime(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SequencerConf::read_RemainingTime) ENABLED START -----*/

    //	Set the attribute value
	if(get_state() == Tango::RUNNING)
	{
		timespec now;
		clock_gettime(CLOCK_MONOTONIC,&now);

		stringstream stepname;
		stepname << string("step")<<step;
		map<string,attr_desc_t >::iterator it = att_data.find(stepname.str());
		if(it != att_data.end())
		{
			double dtime=(now.tv_sec - it->second.start.tv_sec) + ((double)(now.tv_nsec - it->second.start.tv_nsec))/1e9;
			*attr_RemainingTime_read = RemainingTime - floor(dtime);
		}
	}
	else// if(get_state() == Tango::OFF)
	{
		*attr_RemainingTime_read = 0;
	}

    attr.set_value(attr_RemainingTime_read);

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::read_RemainingTime
}

//--------------------------------------------------------
/**
 *	Read ElapsedTime attribute
 *	Description:
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SequencerConf::read_ElapsedTime(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "SequencerConf::read_ElapsedTime(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SequencerConf::read_ElapsedTime) ENABLED START -----*/

    //	Set the attribute value
	if(get_state() == Tango::RUNNING || get_state() == Tango::STANDBY)
	{
		timespec now;
		clock_gettime(CLOCK_MONOTONIC,&now);

		double dtime=(now.tv_sec - start_time.tv_sec) + ((double)(now.tv_nsec - start_time.tv_nsec))/1e9;
		*attr_ElapsedTime_read = floor(dtime);

	}
	/*else if(get_state() != Tango::FAULT)
	{
		*attr_ElapsedTime_read = 0;
	}*/

    attr.set_value(attr_ElapsedTime_read);

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::read_ElapsedTime
}

//--------------------------------------------------------
/**
 *	Method      : SequencerConf::SequencerConfClass::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *	              for specified device.
 */
//--------------------------------------------------------
void SequencerConf::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(SequencerConf::Class::add_dynamic_attributes) ENABLED START -----*/

	//	Add your own code to create and add dynamic attributes if any
	DEBUG_STREAM << __func__ << " entering...";

    if (attr_config_prop.empty() == false)
    {
    	DEBUG_STREAM << __FUNCTION__ << " going to create from device property...";
    	create_dynamic_attributes(attr_config_prop);
    }

    if (attr_config_file.empty() == false)
    {
    	DEBUG_STREAM << __FUNCTION__ << " going to create from file...";
		vector<string> attr_config;
		string line;
		string line_buffer;
		line_buffer = "";
		attr_config.clear();
		ifstream infile (attr_config_file.c_str(), ios_base::in);
		while (getline(infile, line, '\n'))
		{
		  //attr_config.push_back (line);

			if (line[line.size()-1]=='\\')
			{
				line_buffer += line.substr(0, line.size()-1);
			}
			else
			{
				attr_config.push_back (line_buffer + line);
				line_buffer = "";
			}
		}
		if (line_buffer.size())
		{
			attr_config.push_back (line_buffer);
		}
		infile.close();
		DEBUG_STREAM <<__FUNCTION__ << "Read " << attr_config.size() << " lines.\n";
    	create_dynamic_attributes(attr_config);
    }


    //if(done something)
    {
		map<string,attr_desc_t>::iterator attr_it;
		for(attr_it=att_data.begin(); attr_it != att_data.end(); attr_it++)
		{
			Tango::Attr *att;
			DEBUG_STREAM <<__FUNCTION__ << ": going to add type=" << attr_it->second.type;
			if (attr_it->second.type == "bool")
			{
				att = new BoolScalarDynAttrib(attr_it->first);
			}
			else if (attr_it->second.type == "double")
			{
				att = new DoubleScalarDynAttrib(attr_it->first);
			}
			else if (attr_it->second.type == "long")
			{
				att = new LongScalarDynAttrib(attr_it->first);
			}
			else
			{
				continue;
			}

			add_attribute(att);
			set_change_event(attr_it->first, true, false);
			//sort(attr_it->second.begin(), attr_it->second.end(),compare_attr_index);
		}
    }

    init_attributeprop();
    created_attr = true;

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::Class::add_dynamic_attributes

}

//--------------------------------------------------------
/**
 *	Method      : SequencerConf::ControlBoxClass::create_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *	              for specified device.
 */
//--------------------------------------------------------
void SequencerConf::create_dynamic_attributes(vector<string> attr_config)
{
	DEBUG_STREAM << __FUNCTION__ << " entering... attr_index="<<attr_index;

	attr_val_t tmp_val;
	vector<string> filter;
	for(unsigned int i=0; i<MAX_ATTR_SIZE; i++)
		tmp_val.val[i] = false;
	/*attr_val_string_t tmp_val_string;
	for(unsigned int i=0; i<MAX_ATTR_SIZE; i++)
		tmp_val_string.val[i][0] = 0;*/

	//int k=attr_index;
	for (unsigned int i = 0;i < attr_config.size();i++)
	{
		vector<string> results;
		string_explode(attr_config[i], ";", &results);
		bool proxy_err = false;
		if(results[0].find("#") != string::npos)
			continue;
		if(results.size() == 2 || results.size() == 3 || results.size() == 4 || results.size() == 5)
		{
			attr_desc_t tmp;
			sscanf(results[0].c_str(),"step%d",&tmp.step);
			tmp.formula=results[1];
			//remove trailing whitespaces
			if (!tmp.formula.empty() )
			{
				string::size_type pos = tmp.formula.find_last_not_of(' ');
				if (pos != tmp.formula.length()-1)
				{
					if ( pos == string::npos )
						pos = -1;
					tmp.formula.erase(pos+1);
				}
			}

			formula_grammar formula_gr;
			DEBUG_STREAM << __func__<<": going to ast_parse: "<<string(tmp.formula.begin(), tmp.formula.end());
			tmp.formula_tree =
			//boost::spirit::tree_parse_info< std::string::iterator, factory_t> tmp =
					ast_parse<factory_t>(tmp.formula.begin(), tmp.formula.end(), formula_gr, space_p);	//parse string s with grammar al_gr, skipping white spaces
			if (tmp.formula_tree.full)
			{
				find_device_formula(tmp.formula_tree,tmp.remote_name);				//pupulate device list found in this formula

				if (tmp.remote_name.empty() == false)
				{
					//remove duplicated
					sort(tmp.remote_name.begin(), tmp.remote_name.end());
					vector<string>::iterator new_end = \
							unique(tmp.remote_name.begin(), tmp.remote_name.end());
					while (tmp.remote_name.end() != new_end)
					{
						tmp.remote_name.pop_back();
					}

					vector<string>::iterator j = tmp.remote_name.begin();

					while (j != tmp.remote_name.end() && !proxy_err)
					{
						//string device, attribute;
						remote_dev_t tmp_dev;
						string remote_name = *j;
						std::transform(remote_name.begin(), remote_name.end(), remote_name.begin(), (int(*)(int))tolower);		//transform to lowercase
						tmp_dev.remote_name = remote_name;
						const char *c = remote_name.c_str();
						int ind = 0;
						int num_slashes=3;	//not FQDN
						if(remote_name.find("tango://") != string::npos)	//FQDN!!
							num_slashes = 6;
						while (*c)
						{
							if (*c == '/')
								ind++;
							if (ind < num_slashes)
								tmp_dev.remote_device_name.push_back(*c);
							else if (*c != '/')
								tmp_dev.remote_attr_name.push_back(*c);
							c++;
						}
						//if(k<3*MAX_ATTR_SIZE)
						//	tmp_dev.stat_index = k;
						//else
						//	tmp_dev.stat_index = -1;
						try
						{
							tmp_dev.last_read.tv_sec = 0;
							tmp_dev.remote_device = new Tango::DeviceProxy(tmp_dev.remote_device_name);
							//if(k<3*MAX_ATTR_SIZE)
							//	sprintf(log_str[k], "%s: connected", tmp_dev.remote_device_name.c_str());
						}catch (Tango::DevFailed &e)
						{
							string err(e.errors[0].desc);
							INFO_STREAM << __func__ << ": error creating device proxy for " << tmp_dev.remote_device_name << " err="<<err;
							//if(k<3*MAX_ATTR_SIZE)
							//	sprintf(log_str[k], "%s: connection error: '%s'", tmp_dev.remote_device_name.c_str(), err.c_str());
							j++;
							//k++;
							proxy_err = true;
							continue;
						}
						remote_devices.push_back(tmp_dev);
						j++;
						//k++;
					}
					if(proxy_err)
					{
						DEBUG_STREAM << __func__ << ": exited devices loop size="<<tmp.remote_name.size() << " with proxy error! not creating "<<results[0];
						continue;
					}
					DEBUG_STREAM << __func__ << ": exited devices loop size="<<tmp.remote_name.size() << " created="<<remote_devices.size();
				}
			}
			else
			{
		       	ostringstream o;
				o << __func__<<": Parsing Failed, syntax error stopped at " << string(tmp.formula_tree.stop, tmp.formula.end()) << ends; //TODO
		       	DEBUG_STREAM << o.str() << endl;
		       	continue;
			}
			tmp.descr=(results.size() >= 3) ? results[2] : "";
			tmp.error=(results.size() >= 4) ? results[3] : "";
			tmp.timeout=(results.size() >= 5) ? atoi(results[4].c_str()) : defaultStepTimeout;
			tmp.type="bool";

			map<string,attr_desc_t>::iterator f = att_data.find(results[0]);
			if(f!=att_data.end())
			{
				DEBUG_STREAM << __func__ << ": " << results[0] << " found, ERROR already existing";
				//f->second.push_back(tmp);
				//TODO: ERROR already existing
			}
			else
			{
				//DEBUG_STREAM << __func__ << ": " << results[0] << " not found, creating";
				att_data.insert(make_pair(results[0],tmp));
				att_value.insert(make_pair(results[0],tmp_val));
			}
			//DEBUG_STREAM << __func__ << ": ended creating attribute="<<results[0];
		}
		else
		{
			DEBUG_STREAM << __FUNCTION__ << " wrong configuration string size="<<results.size();
		}
		//attr_index = k;
	}
	DEBUG_STREAM << __FUNCTION__ << " exiting...";
}



//========================================================
//	Command execution methods
//========================================================
//--------------------------------------------------------
/**
 *	Execute the Start command:
 *	Description:
 *
 *	@param argin
 *	@returns
 */
//--------------------------------------------------------
void SequencerConf::start()
{
	DEBUG_STREAM << "SequencerConf::start()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SequencerConf::start) ENABLED START -----*/

	//	Add your own code
	if(get_state() == Tango::RUNNING)
	{
		Tango::Except::throw_exception(
			(const char *) "Already Running",
			(const char *) "Already Running",
			(const char *) __func__, Tango::ERR);
	}
	else if(get_state() == Tango::FAULT)
	{
		Tango::Except::throw_exception(
			(const char *) "Acknowledge first",
			(const char *) "Acknowledge first",
			(const char *) __func__, Tango::ERR);
	}
	if(get_state() != Tango::STANDBY)	//OFF
	{
		map<string,attr_val_t >::iterator it_val;
		for(it_val = att_value.begin(); it_val != att_value.end(); it_val++)
		{
			it_val->second.val[0] = false;
		}

		step = 1;
		*attr_Step_read = 1;

		int esttime=0;
		map<string,attr_desc_t>::iterator it_data;
		for(it_data = att_data.begin(); it_data != att_data.end(); it_data++)
		{
			it_data->second.first = true;
			if(it_data->second.step < 1 || (it_data->second.step > (int)att_data.size()))
				continue;
			if(it_data->second.timeout != -1)
				esttime += ceil((double)it_data->second.timeout/1000);
			else
				esttime += ceil((double)defaultStepTimeout/1000);
		}
		RemainingTime = esttime;
		//initialize first step time just to avoid temporary bad value on RemainingTime (till thread updates it)
		stringstream stepname;
		stepname << string("step")<<step;
		map<string,attr_desc_t >::iterator it = att_data.find(stepname.str());
		if(it != att_data.end())
		{
			clock_gettime(CLOCK_MONOTONIC,&it->second.start);
		}

		clock_gettime(CLOCK_MONOTONIC,&start_time);
		set_state(Tango::RUNNING);
		stringstream status;
		status<<"Starting sequence... ("<<step<<"/"<<(att_data.size())<<")";
		set_status(status.str());
		add_log_str("Start");
	}
	else
	{
		set_state(Tango::RUNNING);
		stringstream status;
		status<<"Resuming sequence... ("<<step<<"/"<<(att_data.size())<<")";
		set_status(status.str());
		add_log_str("Resume");
	}

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::start

}

//--------------------------------------------------------
/**
 *	Execute the Stop command:
 *	Description:
 *
 *	@param argin
 *	@returns
 */
//--------------------------------------------------------
void SequencerConf::stop()
{
	DEBUG_STREAM << "SequencerConf::stop()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SequencerConf::stop) ENABLED START -----*/

	//	Add your own code
	//	Add your own code
	if(get_state() != Tango::RUNNING && get_state() != Tango::STANDBY)
	{
		Tango::Except::throw_exception(
			(const char *) "Not Running",
			(const char *) "Not Running",
			(const char *) __func__, Tango::ERR);
	}
	set_state(Tango::OFF);
	stringstream status;
	status<<"Aborted by user ("<<step<<"/"<<(att_data.size())<<")";
	set_status(status.str());
	add_log_str("Stop");
	*attr_Step_read = 0;

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::stop

}

//--------------------------------------------------------
/**
 *	Execute the Pause command:
 *	Description:
 *
 *	@param argin
 *	@returns
 */
//--------------------------------------------------------
void SequencerConf::pause()
{
	DEBUG_STREAM << "SequencerConf::pause()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SequencerConf::pause) ENABLED START -----*/

	//	Add your own code
	//	Add your own code
	if(get_state() != Tango::RUNNING)
	{
		Tango::Except::throw_exception(
			(const char *) "Not Running",
			(const char *) "Not Running",
			(const char *) __func__, Tango::ERR);
	}
	set_state(Tango::STANDBY);
	stringstream status;
	status<<"Paused ("<<step<<"/"<<(att_data.size())<<")";
	set_status(status.str());
	add_log_str("Pause");

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::stop

}

//--------------------------------------------------------
/**
 *	Execute the Acknowledge command:
 *	Description:
 *
 *	@param argin
 *	@returns
 */
//--------------------------------------------------------
void SequencerConf::acknowledge()
{
	DEBUG_STREAM << "SequencerConf::acknowledge()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SequencerConf::acknowledge) ENABLED START -----*/

	//	Add your own code
	//	Add your own code
	if(get_state() != Tango::FAULT)
	{
		Tango::Except::throw_exception(
			(const char *) "Not in Fault",
			(const char *) "Not in Fault",
			(const char *) __func__, Tango::ERR);
	}
	set_state(Tango::OFF);
	stringstream status;
	status<<"Off ("<<step<<"/"<<(att_data.size())<<")";
	set_status(status.str());
	add_log_str("Acknowledge");
	strcpy(steperror_str,"");
	strcpy(stepstatus_str,"");
	*attr_Step_read = 0;
	*attr_ElapsedTime_read = 0;

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::stop

}

	/*----- PROTECTED REGION ID(SequencerConf::namespace_ending) ENABLED START -----*/

	//	Additional Methods
//+------------------------------------------------------------------
/**
 *	method:	SequencerConf::string_explode
 * Explode a string
*/
//+------------------------------------------------------------------
void SequencerConf::string_explode(string str, string separator, vector<string>* results)
{
	unsigned int found;

	found = str.find_first_of(separator);
	while(found != string::npos) {
		if(found > 0) {
			results->push_back(str.substr(0,found));
		}
		str = str.substr(found+1);
		found = str.find_first_of(separator);
	}
	if(str.length() > 0) {
		results->push_back(str);
	}

}

//+------------------------------------------------------------------
/**
 *	method:	SequencerConf::init_attributeprop
 *
 *	description:
 *
 *
 */
//+------------------------------------------------------------------
void SequencerConf::init_attributeprop()
{

	//DEBUG_STREAM << __FUNCTION__ << " entering...";
	Tango::Database *db = new Tango::Database();
	vector <Tango::DbData> vdb_data_set;

	for(map<string,attr_desc_t>::iterator it_att = att_data.begin(); it_att != att_data.end(); it_att++)
	{

		Tango::DbDatum db_datum_attr(it_att->first);
		db_datum_attr << (short)1;	//1 attribute property in 'it_att->first'

		Tango::DbDatum db_datum_descr("Comment");
		Tango::DbData db_data_set;

		vector <string> v_desc;

		stringstream tmp;
		tmp << it_att->first << "='" << it_att->second.formula << "' ("<< it_att->second.descr <<")";
		v_desc.push_back(tmp.str());
		DEBUG_STREAM << __FUNCTION__ << ": "<< tmp.str();

		db_datum_descr << v_desc;
		db_data_set.push_back(db_datum_attr);
		db_data_set.push_back(db_datum_descr);

		vdb_data_set.push_back(db_data_set);
	}
	vector<Tango::DbData>::iterator ite;

	try {
		db->set_timeout_millis(10000);
		for( ite=vdb_data_set.begin() ; ite < vdb_data_set.end(); ite++ )
		{
			db->put_device_attribute_property(get_name(), *ite);
		}
	} catch (Tango::DevFailed &e) {
		INFO_STREAM << "SequencerConf::init_attributeprop() init attributeprop failed"<<endl;
		Tango::Except::print_exception(e);
	}
	delete db;
}

long SequencerConf::create_dynamic_command(const char* cmd_name, Tango::CmdArgType type_in, Tango::CmdArgType type_out, long size_in, long size_out)
{

	std::vector< Tango::Command* >& command_list = get_device_class()->get_command_list();
	bool found = false;
	std::vector< Tango::Command* >::iterator it;
	for(it=command_list.begin(); it!= command_list.end(); it++)
	{
		if((*it)->get_name()==string(cmd_name))
		{
			found = true;
			break;
		}
	}
	if(!found)
		command_list.push_back(new CmdClass(cmd_name,
				type_in, type_out,
				"argin",
				"argout",
				Tango::OPERATOR,
				size_in,
				this));

	return 0;
}


//==============================================================
//------------------- AST evaluation methods -------------------
//==============================================================
double SequencerConf::eval_formula(tree_parse_info_t tree, string attr_name, string &attr_values)
{
    return eval_expression(tree.trees.begin(), attr_name, attr_values);
}

double SequencerConf::eval_expression(iter_t const& i, string attr_name, string &attr_values) //throw (string &), std::out_of_range
{
    ostringstream err;
    err << "Evaluating formula: ";
	while(get_state() == Tango::STANDBY && !read_loop->abortflag)
	{
		usleep(500000);
	}
	if(get_state() == Tango::OFF)
	{
		throw string("aborted");
	}
	timespec now;
	clock_gettime(CLOCK_MONOTONIC,&now);
	map<string,attr_desc_t>::iterator it=att_data.find(attr_name);
	if(it==att_data.end())
	{
    	err <<  " not found: " << attr_name;
    	throw err.str();
	}
	double dtime_ms=(now.tv_sec - it->second.start.tv_sec)*1e3 + ((double)(now.tv_nsec - it->second.start.tv_nsec))/1e6;
	if(it->second.timeout != -1 && dtime_ms > it->second.timeout)
	{
    	throw string("TIMEOUT");
	}

    //iter_t it = i->children.begin();

    if (i->value.id() == formula_grammar::val_rID)
    {
        if(i->children.size() != 0)
        {
        	err <<  "in node val_rID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }
        string val_d(i->value.begin(), i->value.end());
		INFO_STREAM << "		node value real = " << val_d << endl;
        return strtod(val_d.c_str(), 0);
    }
    else if (i->value.id() == formula_grammar::val_hID)
    {
        if(i->children.size() != 0)
        {
        	err <<  "in node val_hID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }
        string val_d(i->value.begin(), i->value.end());
		INFO_STREAM << "		node value hex = " << val_d << endl;
        return strtod(val_d.c_str(), 0);
    }
    else if (i->value.id() == formula_grammar::val_stID)
    {
        if(i->children.size() != 0)
        {
        	err <<  "in node val_stID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }
        string val_st(i->value.begin(), i->value.end());

        double st =  i->value.value();			//get value directly from node saved with access_node_d
		INFO_STREAM << "		node value state : " << val_st << "=" << st << endl;
        return st;
    }
    else if (i->value.id() == formula_grammar::unary_exprID)
    {
		DEBUG_STREAM << "		node unary expression: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 1)
        {
        	err <<  "in node unary_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }
        if (*i->value.begin() == '+')
        	return + eval_expression(i->children.begin(), attr_name, attr_values);
        if (*i->value.begin() == '-')
        	return - eval_expression(i->children.begin(), attr_name, attr_values);
        if (*i->value.begin() == '!')
        	return ! eval_expression(i->children.begin(), attr_name, attr_values);
        /*if (*i->value.begin() == '~')
        	return ~ eval_expression(i->children.begin(), attr_name, attr_values);*/	//TODO
    }
    else if (i->value.id() == formula_grammar::mult_exprID)
    {
		DEBUG_STREAM << "		node mult expression: " << string(i->value.begin(), i->value.end()) << endl;
       	if(i->children.size() != 2)
        {
        	err <<  "in node mult_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }
        if (*i->value.begin() == '*')
        {
            return eval_expression(i->children.begin(), attr_name, attr_values) *
                eval_expression(i->children.begin()+1, attr_name, attr_values);
        }
        else if (*i->value.begin() == '/')
        {
            return eval_expression(i->children.begin(), attr_name, attr_values) /
                eval_expression(i->children.begin()+1, attr_name, attr_values);
        }
        else
        {
        	err <<  "in node mult_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
        	throw err.str();
        }
    }
    else if (i->value.id() == formula_grammar::add_exprID)
    {
        DEBUG_STREAM << "		node add expression: " << string(i->value.begin(), i->value.end()) << endl;
        if(i->children.size() != 2)
        {
        	err <<  "in node add_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }
        if (*i->value.begin() == '+')
        {
            return eval_expression(i->children.begin(), attr_name, attr_values) +
                eval_expression(i->children.begin()+1, attr_name, attr_values);
        }
        else if (*i->value.begin() == '-')
        {
            return eval_expression(i->children.begin(), attr_name, attr_values) -
                eval_expression(i->children.begin()+1, attr_name, attr_values);
        }
        else
        {
        	err <<  "in node add_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
        	throw err.str();
        }
    }
    else if (i->value.id() == formula_grammar::event_ID)
    {
		DEBUG_STREAM << "		node event" << string(i->value.begin(), i->value.end()) << endl;
    	err <<  "in node event_ID(" << string(i->value.begin(), i->value.end()) << ") PARSE ERROR: not allowed as leaf node";
    	throw err.str();

/*		int ind;
		if(i->children.size() != 2)
		{
        	err <<  "in node event_ID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;;
        	throw err.str();
        }
		if((i->children.begin()+1)->value.id() == formula_grammar::indexID)
			ind = (int)eval_expression(i->children.begin()+1, attr_name, attr_values);		//array index
		else
		{
        	err <<  "in node event_ID(" << string(i->value.begin(), i->value.end()) << ") children2 is not an index ->" << string((i->children.begin()+1)->value.begin(), (i->children.begin()+1)->value.end()) << ends;;
        	throw err.str();
        }
		return eval_expression(i->children.begin(), attr_name, attr_values ,ind);*/
    }
    else if (i->value.id() == formula_grammar::nameID)
    {
    	err <<  "in node nameID(" << string(i->value.begin(), i->value.end()) << ") PARSE ERROR: not allowed as indipendent node";
    	throw err.str();
		/*if(i->children.size() != 0)
		{
        	err <<  "in node nameID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }

		string name_id(i->value.begin(), i->value.end());
		std::transform(name_id.begin(), name_id.end(), name_id.begin(), (int(*)(int))tolower);		//transform to lowercase
		vector<remote_dev_t>::iterator it;
		for(it=remote_devices.begin(); it!=remote_devices.end(); it++)
		{
			//DEBUG_STREAM << __func__<<": looking for " << name_id << " now is "<< it->remote_name;
			if(it->remote_name == name_id)
				break;
		}

		if(it != remote_devices.end())
		{
			struct timespec now;
			clock_gettime(CLOCK_MONOTONIC,&now);
			double diff_time_poll_s = fabs((now.tv_sec - it->last_read.tv_sec) + ((double)(now.tv_nsec - it->last_read.tv_nsec))/1e9);
			double diff_time_ev_s = fabs((now.tv_sec - it->last_event_rx.tv_sec) + ((double)(now.tv_nsec - it->last_event_rx.tv_nsec))/1e9);


			if((diff_time_poll_s > 2+polling_period+read_timeout) && (diff_time_ev_s > 2+polling_period+read_timeout) && polling_period > 0)
			{
				err <<  "in node nameID(" << name_id << ") value not valid! (TIMEOUT diff_time_poll_s="<<diff_time_poll_s<<" diff_time_ev_s="<<diff_time_ev_s<<") " << ends;
        		throw err.str();
        	}

			if(ev_ind >= it->value.size())
			{
				err <<  "in node nameID(" << name_id << ") index ("<<ev_ind<<") out of range (size="<<it->value.size()<<")" << ends;
        		throw err.str();
        	}

			ostringstream temp_attr_val;
			temp_attr_val << it->remote_name << "[" << ev_ind << "]=" <<it->value.at(ev_ind) << ";";
			attr_values += temp_attr_val.str();
			INFO_STREAM << "		node name -> " << temp_attr_val.str() << endl;
			return it->value.at(ev_ind);		//throw  std::out_of_range
		}
		else
		{
			err <<  "in event: (" << name_id << ") not found in event table" << ends;
        	throw err.str();
		}*/
    }
    else if (i->value.id() == formula_grammar::indexID)
    {
		if(i->children.size() != 0)
		{
        	err <<  "in node indexID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }
        string val_d(i->value.begin(), i->value.end());
     	DEBUG_STREAM << "		node index = " << val_d << endl;
        return strtod(val_d.c_str(), 0);
    }
    else if (i->value.id() == formula_grammar::logical_exprID)
    {
		DEBUG_STREAM << "		node logical expression: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 2)
		{
        	err <<  "in node logical_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }
		if (string(i->value.begin(), i->value.end()) == string("&&"))
        {
			if((i->children.begin()+1)->value.id() != formula_grammar::func_gotoID)
			{
				return eval_expression(i->children.begin(), attr_name, attr_values) &&
		                eval_expression(i->children.begin()+1, attr_name, attr_values);
			}
			else	//if goto return goto value and not && result
			{
				if(eval_expression(i->children.begin(), attr_name, attr_values))
					return eval_expression(i->children.begin()+1, attr_name, attr_values);
				else
					return 0;
			}
        }
		else if (string(i->value.begin(), i->value.end()) == string("||"))
        {
            return eval_expression(i->children.begin(), attr_name, attr_values) ||
                eval_expression(i->children.begin()+1, attr_name, attr_values);
        }
        else
        {
        	err <<  "in node logical_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
        	throw err.str();
        }
    }
    else if (i->value.id() == formula_grammar::bitwise_exprID)
    {
		DEBUG_STREAM << "		node bitwise expression: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 2)
		{
        	err <<  "in node bitwise_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }
        double val_d1=eval_expression(i->children.begin(), attr_name, attr_values),
           	val_d2=eval_expression(i->children.begin()+1, attr_name, attr_values);
        long val_l1,val_l2;

    	string err2("ERROR: non-int value in bitwise operation!");
    	val_l1 = (long)trunc(val_d1);		//transform to long
    	val_l2 = (long)trunc(val_d2);		//transform to long

	    if((val_l1 != val_d1) || (val_l2 != val_d2))	//if different, lost something with truncf
    		throw err2;

        if (*i->value.begin() == '&')
        {
            return (double)(val_l1 & val_l2);
        }
        else if (*i->value.begin() == '|')
        {
            return (double)(val_l1 | val_l2);
        }
        else if (*i->value.begin() == '^')
        {
            return (double)(val_l1 ^ val_l2);
        }
        else
        {
        	err << "in node bitwise_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
        	throw err.str();
        }
    }
    else if (i->value.id() == formula_grammar::shift_exprID)
    {
		DEBUG_STREAM << "		node shift expression: " << string(i->value.begin(), i->value.end()) << endl;
		//assert(i->children.size() == 2);
		if(i->children.size() != 2)
		{
        	err <<  "in node shift_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }
        double val_d1=eval_expression(i->children.begin(), attr_name, attr_values),
           	val_d2=eval_expression(i->children.begin()+1, attr_name, attr_values);
        long val_l1,val_l2;

    	string err2("ERROR: non-int value in bitwise operation!");
    	val_l1 = (long)trunc(val_d1);		//transform to long
    	val_l2 = (long)trunc(val_d2);		//transform to long

	    if((val_l1 != val_d1) || (val_l2 != val_d2))	//if different, lost something with truncf
    		throw err2;

        if (string(i->value.begin(), i->value.end()) == string("<<"))
        {
            return (double)(val_l1 << val_l2);
        }
        else if (string(i->value.begin(), i->value.end()) == string(">>"))
        {
            return (double)(val_l1 >> val_l2);
        }
        else
        {
        	err <<  "in node shift_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
        	throw err.str();
        }
    }
    else if (i->value.id() == formula_grammar::equality_exprID)
    {
		DEBUG_STREAM << "		node equality expression: " << string(i->value.begin(), i->value.end()) << endl;
        if(i->children.size() != 2)
		{
        	err <<  "in node equality_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }

        //string comparison here
        iter_t const& i2_1 = i->children.begin();
        iter_t const& i2_2 = i->children.begin()+1;
        //OK only attr == 'string' or attr != 'string'
       // if(i2_1->value.id() == formula_grammar::nameID && i2_2->value.id() == formula_grammar::val_stringID)
        if(i2_1->value.id() == formula_grammar::func_tangoID && i2_2->value.id() == formula_grammar::val_stringID)
        {
        	//retrieve string from formula
        	string val_string(i2_2->value.begin(), i2_2->value.end());
        	double val;
        	string attr_val;
        	eval_func_tango(i2_1, attr_name, attr_values, val, attr_val);
        	DEBUG_STREAM << "		node equality FUNC TANGO("<<attr_val<<") COMPARE STRING("<<val_string<<")";

			if (string(i->value.begin(), i->value.end()) == string("!="))
			{
				return attr_val != val_string;
			}
			else if (string(i->value.begin(), i->value.end()) == string("=="))
			{
				return attr_val == val_string;
			}
			else
			{
				err <<  "in node equality_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed (val_stringID)" << ends;
				throw err.str();
			}
#if 0
            if(i2_1->children.size() == 0 && i2_2->children.size() == 0)
            {
            	//retrieve string from attribute:
            	string attr_val = "";
            	string name_id(i2_1->value.begin(), i2_1->value.end());
				std::transform(name_id.begin(), name_id.end(), name_id.begin(), (int(*)(int))tolower);		//transform to lowercase
				vector<remote_dev_t>::iterator it;
				for(it=remote_devices.begin(); it!=remote_devices.end(); it++)
				{
					//DEBUG_STREAM << __func__<<": looking for " << name_id << " now is "<< it->remote_name;
					if(it->remote_name == name_id)
						break;
				}

				if(it != remote_devices.end())
				{
					struct timespec now;
					clock_gettime(CLOCK_MONOTONIC,&now);
					double diff_time_poll_s = fabs((now.tv_sec - it->last_read.tv_sec) + ((double)(now.tv_nsec - it->last_read.tv_nsec))/1e9);
					double diff_time_ev_s = fabs((now.tv_sec - it->last_event_rx.tv_sec) + ((double)(now.tv_nsec - it->last_event_rx.tv_nsec))/1e9);


					if((diff_time_poll_s > 2+polling_period+read_timeout) && (diff_time_ev_s > 2+polling_period+read_timeout) && polling_period > 0)
					{
						err <<  "in node nameID(" << string(i->value.begin(), i->value.end()) << ") value not valid! (TIMEOUT 2 diff_time_poll_s="<<diff_time_poll_s<<" diff_time_ev_s="<<diff_time_ev_s<<")" << ends;
						throw err.str();
					}

					ostringstream temp_attr_val;
					temp_attr_val << it->remote_name << "=" <<it->value_string << ";";
					attr_values += temp_attr_val.str();
					INFO_STREAM << "		node name string -> " << temp_attr_val.str() << endl;
					attr_val =  string("'") + it->value_string + string("'");
				}
				else
				{
					err <<  "in event: (" << string(i->value.begin(), i->value.end()) << ") not found in event table" << ends;
					throw err.str();
				}
            	//retrieve string from formula
            	string val_string(i2_2->value.begin(), i2_2->value.end());

    			if (string(i->value.begin(), i->value.end()) == string("!="))
    			{
    				return attr_val != val_string;
    			}
    			else if (string(i->value.begin(), i->value.end()) == string("=="))
    			{
    				return attr_val == val_string;
    			}
    			else
    			{
    				err <<  "in node equality_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed (val_stringID)" << ends;
    				throw err.str();
    			}
            }
#endif
        }
        else
        {
			if (string(i->value.begin(), i->value.end()) == string("!="))
			{
				return eval_expression(i->children.begin(), attr_name, attr_values) !=
					eval_expression(i->children.begin()+1, attr_name, attr_values);
			}
			else if (string(i->value.begin(), i->value.end()) == string("=="))
			{
				return eval_expression(i->children.begin(), attr_name, attr_values) ==
					eval_expression(i->children.begin()+1, attr_name, attr_values);
			}
			else
			{
				err <<  "in node equality_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
				throw err.str();
			}
        }
    }
    else if (i->value.id() == formula_grammar::compare_exprID)
    {
		DEBUG_STREAM << "		node compare expression: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 2)
		{
        	err <<  "in node compare_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }
		if (string(i->value.begin(), i->value.end()) == string("<="))
        {
            return eval_expression(i->children.begin(), attr_name, attr_values) <=
                eval_expression(i->children.begin()+1, attr_name, attr_values);
        }
		else if (string(i->value.begin(), i->value.end()) == string(">="))
        {
            return eval_expression(i->children.begin(), attr_name, attr_values) >=
                eval_expression(i->children.begin()+1, attr_name, attr_values);
        }
        else if (*i->value.begin() == '<')
        {
            return eval_expression(i->children.begin(), attr_name, attr_values) <
                eval_expression(i->children.begin()+1, attr_name, attr_values);
        }
        else if (*i->value.begin() == '>')
        {
            return eval_expression(i->children.begin(), attr_name, attr_values) >
                eval_expression(i->children.begin()+1, attr_name, attr_values);
        }
        else
        {
        	err <<  "in node equality_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
        	throw err.str();
        }
    }
    else if (i->value.id() == formula_grammar::funcID)
    {
		DEBUG_STREAM << "		node function: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 1)
		{
        	err <<  "in node funcID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }
		return fabs(eval_expression(i->children.begin(), attr_name, attr_values));			//now handled only abs as function
    }
    else if (i->value.id() == formula_grammar::func_dualID)
    {
		DEBUG_STREAM << "		node function dual: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 2)
		{
        	err <<  "in node func_dualID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }
		if (string(i->value.begin(), i->value.end()) == string("min"))
        {
            return min(eval_expression(i->children.begin(), attr_name, attr_values),
            		eval_expression(i->children.begin()+1, attr_name, attr_values));
        }
		else if (string(i->value.begin(), i->value.end()) == string("max"))
        {
            return max(eval_expression(i->children.begin(), attr_name, attr_values),
                eval_expression(i->children.begin()+1, attr_name, attr_values));
        }
        else
        {
        	err <<  "in node func_dualID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
        	throw err.str();
        }
    }
    else if (i->value.id() == formula_grammar::cond_exprID)
    {
		DEBUG_STREAM << "		node ternary_if expression: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 3)
		{
        	err <<  "in node cond_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }
		if(eval_expression(i->children.begin(), attr_name, attr_values))
			return (eval_expression(i->children.begin()+1, attr_name, attr_values));
		else
			return (eval_expression(i->children.begin()+2, attr_name, attr_values));
    }
    else if (i->value.id() == formula_grammar::func_tangoID)
    {
		DEBUG_STREAM << "		node Tango function: " << string(i->value.begin(), i->value.end()) << ", children=" << i->children.size() << endl;
		if(i->children.size() != 1 && i->children.size() != 2 && i->children.size() != 3 && i->children.size() != 4)
		{
        	err <<  "in node func_tangoID(" << string(i->value.begin(), i->value.end()) << "), children=" << i->children.size() << ends;
        	throw err.str();
        }
		double val=0;
		string val_s("");
		eval_func_tango(i, attr_name, attr_values, val,val_s);
		DEBUG_STREAM << "		node Tango function: " << string(i->value.begin(), i->value.end()) << ", returned val_d=" << val << " val_s="<<val_s << endl;
		return val;
    }
    else if (i->value.id() == formula_grammar::func_gotoID)
	{
		DEBUG_STREAM << "		node goto: " << string(i->value.begin(), i->value.end()) << " children=" << i->children.size() << endl;

		for(iter_t i2_1=i->children.begin(); i2_1!=i->children.end(); i2_1++)
		{
			DEBUG_STREAM << "			childrens of goto: " << string(i2_1->value.begin(), i2_1->value.end()) << endl;
		}

		if(i->children.size() != 1)
		{
			err <<  "in node func_gotoID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		iter_t const& i2_1 = i->children.begin();
        string val_d(i2_1->value.begin(), i2_1->value.end());
		INFO_STREAM << "		node value goto = " << val_d << endl;
        return strtod(val_d.c_str(), 0);
	}
    else if (i->value.id() == formula_grammar::val_sleepID)
	{
		DEBUG_STREAM << "		node sleep: " << string(i->value.begin(), i->value.end()) << " children=" << i->children.size() << endl;
		if(i->children.size() != 1)
		{
			err <<  "in node val_sleepID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		iter_t const& i2_1 = i->children.begin();
		if(i2_1->children.size() != 0)
		{
			err <<  "in node val_sleepID(" << string(i2_1->value.begin(), i2_1->value.end()) << ") children=" << i2_1->children.size() << ends;
			throw err.str();
		}
        string val_d(i2_1->value.begin(), i2_1->value.end());
		INFO_STREAM << "		node value sleep = " << val_d << endl;
		abort_sleep(int(strtod(val_d.c_str(), 0)));
        return 1;
	}
    else
    {
        DEBUG_STREAM << "		node unknown id: " << string(i->value.begin(), i->value.end()) << endl;
        {
        	err <<  "node unknown!! value=" << string(i->value.begin(), i->value.end()) << ends;
        	throw err.str();
        }
    }

    return 0;
}

void SequencerConf::eval_func_tango(iter_t const& i, string attr_name, string &attr_values, double &value, string &string_value) //throw (string &), std::out_of_range
{
    ostringstream err;
    err << "Evaluating formula: ";
    iter_t const& i2_1 = i->children.begin();
    //iter_t const& i2_2 = i->children.begin()+1;

	if(string(i->value.begin(), i->value.end()) == string("read") && (i->children.size() == 1 || i->children.size() == 2) && i2_1->value.id() == formula_grammar::nameID)
	{
		int ind=-1;
		if(i->children.size() == 2 && (i->children.begin()+1)->value.id() == formula_grammar::indexID)
		{
			DEBUG_STREAM << "		node index " << string(i2_1->value.begin(), i2_1->value.end()) << "[" << string((i->children.begin()+1)->value.begin(), (i->children.begin()+1)->value.end())<<"]" << endl;

			if((i->children.begin()+1)->value.id() == formula_grammar::indexID)
				ind = (int)eval_expression(i->children.begin()+1, attr_name, attr_values);		//array index
		}
		else if(i->children.size() != 1)
		{
			err <<  "in node func_tangoID(" << string(i2_1->value.begin(), i2_1->value.end()) << ") =" << i2_1->children.size() << ends;;
			throw err.str();
		}
		stringstream ind_ss;
		ind_ss << ind;

		//read attribute
		//map<string,vector<attr_desc_t> >::iterator it=att_data.find(attr_name);
		value=0;
		string_value="";
		vector<remote_dev_t>::iterator it_ev=remote_devices.end();
		it_ev=find_events(string(i2_1->value.begin(), i2_1->value.end()));
		stringstream status;
		status<<"Running ("<<step<<"/"<<att_data.size()<<")(read_attribute("<<it_ev->remote_name<<"))";
		set_status(status.str());
		if(ind == -1)
			add_log_str(string("read_attribute(")+it_ev->remote_name+")");
		else
			add_log_str(string("read_attribute(")+it_ev->remote_name+"["+ind_ss.str()+"])");
		Tango::DeviceAttribute Dout;
		try
		{
			Dout = it_ev->remote_device->read_attribute(it_ev->remote_attr_name);
			extract_values(&Dout, it_ev->value, it_ev->value_string);
		}
		catch(Tango::DevFailed &e)
		{
        	err <<  "in node func_tangoID(" << string(i->value.begin(), i->value.end()) << ") read_attribute exception=" << e.errors[0].desc;
        	throw err.str();
		}
		if(ind >= (int)it_ev->value.size() && ind >= (int)it_ev->value_string.size())
		{
        	err <<  "in node func_tangoID(" << string(i->value.begin(), i->value.end()) << ") read_attribute error=wrong index requested";
        	throw err.str();
		}
		//if(!value_string)
		{
			if(it_ev->value.size() >= 1 && ind>=0 && ind < it_ev->value.size())
				value = it_ev->value.at(ind);
			else if(it_ev->value.size() >= 1 && ind < 0)
				value = *it_ev->value.begin();
		}
		//else
		{
			if(it_ev->value_string.size() >= 1 && ind>=0 && ind < it_ev->value_string.size())
				string_value = string("'")+it_ev->value_string.at(ind)+string("'");
			else if(it_ev->value_string.size() >= 1 && ind < 0)
				string_value = string("'")+*it_ev->value_string.begin()+string("'");
		}
		return;
	}
	/*else if(string(i->value.begin(), i->value.end()) == string("write") && i2_1->value.id() == formula_grammar::nameID && (i->children.size() == 3 &&
			(((i->children.begin()+2)->value.id() == formula_grammar::val_rID) || ((i->children.begin()+2)->value.id() == formula_grammar::val_hID) ||
			((i->children.begin()+2)->value.id() == formula_grammar::val_stID) || ((i->children.begin()+2)->value.id() == formula_grammar::val_stringID))) ||
			(i->children.size() == 4 && (i->children.begin()+1)->value.id() == formula_grammar::indexID &&
			(((i->children.begin()+3)->value.id() == formula_grammar::val_rID) || ((i->children.begin()+3)->value.id() == formula_grammar::val_hID) ||
			((i->children.begin()+3)->value.id() == formula_grammar::val_stID) || ((i->children.begin()+3)->value.id() == formula_grammar::val_stringID))) ||
			(i->children.size() == 5 && (i->children.begin()+1)->value.id() == formula_grammar::indexID &&	//TODO: i->children.size() == 6 to handle index?
			(string((i->children.begin()+3)->value.begin(), (i->children.begin()+3)->value.end())=="read") &&
			((i->children.begin()+4)->value.id() == formula_grammar::nameID)))*/
	else if(string(i->value.begin(), i->value.end()) == string("write") && i2_1->value.id() == formula_grammar::nameID && (i->children.size() == 3  ||
			(i->children.size() == 4 && (i->children.begin()+1)->value.id() == formula_grammar::indexID)))
	{
		iter_t i2_2;
		int ind=-1;
		if(i->children.size() == 4 && (i->children.begin()+1)->value.id() == formula_grammar::indexID)
		{
			DEBUG_STREAM << "		node index " << string(i2_1->value.begin(), i2_1->value.end()) << "[" << string((i->children.begin()+1)->value.begin(), (i->children.begin()+1)->value.end())<<"]" << endl;

			ind = (int)eval_expression(i->children.begin()+1, attr_name, attr_values);		//array index
			i2_2 = i->children.begin()+3;
		}
		else if(i->children.size() != 3 && i->children.size() != 4)
		{
			stringstream tmp;
			for(int u=0; u<i->children.size(); u++)
				tmp << u<< "="<<string((i->children.begin()+u)->value.begin(), (i->children.begin()+u)->value.end()) << " ";
			//cout << " i->children.size()="<< i->children.size()<< " 1="<<string(i2_1->value.begin(), i2_1->value.end())<< " 2="<<string((i->children.begin()+2)->value.begin(), (i->children.begin()+2)->value.end()) <<endl;
			err <<  "in node func_tangoID(write) childrens="<<tmp.str();
			throw err.str();
		}
		else
		{
			i2_2 = i->children.begin()+2;
		}
		stringstream ind_ss;
		ind_ss << ind;

		//iter_t const& i2_2 = i->children.begin()+2;
		//write attribute
		vector<remote_dev_t>::iterator it_ev=remote_devices.end();
		it_ev=find_events(string(i2_1->value.begin(), i2_1->value.end()));
		try
		{
			if(i2_2->value.id() == formula_grammar::val_rID || i2_2->value.id() == formula_grammar::val_hID)
			{
				stringstream status;
				status<<"Running ("<<step<<"/"<<att_data.size()<<")(write_attribute("<<it_ev->remote_name<<"))";
				set_status(status.str());
				if(ind == -1)
					add_log_str(string("write_attribute(")+it_ev->remote_name+")="+string(i2_2->value.begin(), i2_2->value.end()));
				else
					add_log_str(string("write_attribute(")+it_ev->remote_name+"["+ind_ss.str()+"])="+string(i2_2->value.begin(), i2_2->value.end()));
				DEBUG_STREAM << "		node Tango function: going to write(" << it_ev->remote_attr_name << ") val=" << string(i2_2->value.begin(), i2_2->value.end()) << endl;

				string val_d(i2_2->value.begin(), i2_2->value.end());
				vector<double> vval;
				vector<string> ss;
				//TODO ind for spectrum

				if(ind > -1)
				{
					Tango::DeviceAttribute Dout;
					Dout = it_ev->remote_device->read_attribute(it_ev->remote_attr_name);
					string tmp;
					extract_set_values(&Dout, vval, tmp);	//TODO: OK set values?
					if(ind < (int)vval.size())
					{
						vval[ind] = strtod(val_d.c_str(), 0);
					}
					else
					{
						for(int i=vval.size(); i<ind; i++)
						{
							vval.push_back(0);	//TODO: OK to fill with 0?
						}
						vval.push_back(strtod(val_d.c_str(), 0));
					}
				}
				else
				{
					vval.push_back(strtod(val_d.c_str(), 0));
				}
				Tango::AttributeInfoEx attr_info = it_ev->remote_device->get_attribute_config(it_ev->remote_attr_name);
				Tango::DeviceAttribute *Din = insert_values(attr_info,it_ev->remote_attr_name,vval,ss);
				it_ev->remote_device->write_attribute(*Din);
				delete Din;
			}
			else if(i2_2->value.id() == formula_grammar::val_stID)
			{
				stringstream status;
				status<<"Running ("<<step<<"/"<<att_data.size()<<")(write_attribute("<<it_ev->remote_name<<"))";
				set_status(status.str());
				if(ind == -1)
					add_log_str(string("write_attribute(")+it_ev->remote_name+")="+string(i2_2->value.begin(), i2_2->value.end()));
				else
					add_log_str(string("write_attribute(")+it_ev->remote_name+"["+ind_ss.str()+"])="+string(i2_2->value.begin(), i2_2->value.end()));
				DEBUG_STREAM << "		node Tango function: going to write(" << it_ev->remote_attr_name << ") val=" << string(i2_2->value.begin(), i2_2->value.end()) << endl;

				//TODO: array
		        //string val_st(i2_2->value.begin(), i2_2->value.end());

		        double st =  (Tango::DevState)i2_2->value.value();			//get value directly from node saved with access_node_d

				vector<double> vval;
				vector<string> ss;
				vval.push_back(st);
				Tango::AttributeInfoEx attr_info = it_ev->remote_device->get_attribute_config(it_ev->remote_attr_name);
				Tango::DeviceAttribute *Din=insert_values(attr_info,it_ev->remote_attr_name,vval,ss);
				it_ev->remote_device->write_attribute(*Din);
				delete Din;
			}
			else if(i2_2->value.id() == formula_grammar::val_stringID)
			{
				stringstream status;
				status<<"Running ("<<step<<"/"<<att_data.size()<<")(write_attribute("<<it_ev->remote_name<<"))";
				set_status(status.str());
				if(ind == -1)
					add_log_str(string("write_attribute(")+it_ev->remote_name+")="+string(i2_2->value.begin(), i2_2->value.end()));
				else
					add_log_str(string("write_attribute(")+it_ev->remote_name+"["+ind_ss.str()+"])="+string(i2_2->value.begin(), i2_2->value.end()));
				DEBUG_STREAM << "		node Tango function: going to write(" << it_ev->remote_attr_name << ") val=" << string(i2_2->value.begin(), i2_2->value.end()) << endl;

				//TODO: array
		        string val_st(i2_2->value.begin()+1, i2_2->value.end()-1);
				vector<double> vval;
				vector<string> ss;
				ss.push_back(val_st);
				Tango::AttributeInfoEx attr_info = it_ev->remote_device->get_attribute_config(it_ev->remote_attr_name);
				Tango::DeviceAttribute *Din=insert_values(attr_info,it_ev->remote_attr_name,vval,ss);
				it_ev->remote_device->write_attribute(*Din);
				delete Din;
			}
			else// if(i2_2->value.id() == formula_grammar::cond_exprID)
			{
				//TODO: cond_exprID can return only dobule val, not string
				//TODO: array
		        double val_expr = eval_expression(i2_2, attr_name, attr_values);
				stringstream status;
				status<<"Running ("<<step<<"/"<<att_data.size()<<")(write_attribute("<<it_ev->remote_name<<"))";
				set_status(status.str());
				stringstream val_expr_ss;
				val_expr_ss << val_expr;
				if(ind == -1)
					add_log_str(string("write_attribute(")+it_ev->remote_name+")="+val_expr_ss.str());
				else
					add_log_str(string("write_attribute(")+it_ev->remote_name+"["+ind_ss.str()+"])="+val_expr_ss.str());
				DEBUG_STREAM << "		node Tango function: going to write(" << it_ev->remote_attr_name << ") val=" << val_expr << endl;

				vector<double> vval;
				vector<string> ss;
				vval.push_back(val_expr);
				Tango::AttributeInfoEx attr_info = it_ev->remote_device->get_attribute_config(it_ev->remote_attr_name);
				Tango::DeviceAttribute *Din=insert_values(attr_info,it_ev->remote_attr_name,vval,ss);
				it_ev->remote_device->write_attribute(*Din);
				delete Din;
			}
		}
		catch(Tango::DevFailed &e)
		{
        	err <<  "in node func_tangoID(" << string(i->value.begin(), i->value.end()) << ") write_attribute exception=" << e.errors[0].desc;
        	throw err.str();
		}
		value = 1;
		return;
	}
	//read command
	else if(string(i->value.begin(), i->value.end()) == string("command") && i->children.size() == 1 && i2_1->value.id() == formula_grammar::nameID)
	{
		//read attribute
		//map<string,vector<attr_desc_t> >::iterator it=att_data.find(attr_name);
		value=0;
		string_value="";
		vector<remote_dev_t>::iterator it_ev=remote_devices.end();
		it_ev=find_events(string(i2_1->value.begin(), i2_1->value.end()));
		stringstream status;
		status<<"Running ("<<step<<"/"<<att_data.size()<<")(command("<<it_ev->remote_name<<"))";
		set_status(status.str());
		add_log_str(string("command(")+it_ev->remote_name+")");
		Tango::DeviceAttribute Dout;
		try
		{
			Tango::DeviceData Dout;
			Tango::CommandInfo cinfo = it_ev->remote_device->command_query(it_ev->remote_attr_name);
			Dout = it_ev->remote_device->command_inout(it_ev->remote_attr_name);
			//TODO: temporary!! fix extract_values!
			if(it_ev->remote_attr_name != "state" && cinfo.out_type != Tango::DEV_VOID)
			{
				extract_values(&Dout, it_ev->value, it_ev->value_string);
			}
			else if(cinfo.out_type != Tango::DEV_VOID)
			{
				Tango::DevState stval;
				Dout >> stval;
				it_ev->value.push_back((double)stval);
			}
			else
			{
				//cout <<__func__<< ": "<<it_ev->remote_attr_name << " -> DEV_VOID command"<< endl;
				it_ev->value.push_back((double)1);
			}
		}
		catch(Tango::DevFailed &e)
		{
			cout << "exception -> READ COMMAND" << endl;
        	err <<  "in node func_tangoID(" << string(i->value.begin(), i->value.end()) << ") read command_inout exception=" << e.errors[0].desc;
        	throw err.str();
		}
		if(it_ev->value.size() >= 1)
			value = *it_ev->value.begin();
		if(it_ev->value_string.size() >= 1)
			string_value = *it_ev->value_string.begin();
		//TODO: array
		return;
	}
	//write command
	else if(string(i->value.begin(), i->value.end()) == string("command") && i->children.size() == 3 && i2_1->value.id() == formula_grammar::nameID &&
			(((i->children.begin()+2)->value.id() == formula_grammar::val_rID) || ((i->children.begin()+2)->value.id() == formula_grammar::val_hID) ||
			((i->children.begin()+2)->value.id() == formula_grammar::val_stID) || ((i->children.begin()+2)->value.id() == formula_grammar::val_stringID)))
	{
		iter_t const& i2_2 = i->children.begin()+2;
		//write attribute
		vector<remote_dev_t>::iterator it_ev=remote_devices.end();
		it_ev=find_events(string(i2_1->value.begin(), i2_1->value.end()));
		stringstream status;
		status<<"Running ("<<step<<"/"<<att_data.size()<<")(command("<<it_ev->remote_name<<"))";
		set_status(status.str());
		add_log_str(string("command(")+it_ev->remote_name+")="+string(i2_2->value.begin(), i2_2->value.end()));
		DEBUG_STREAM << "		node Tango function: going to write(" << it_ev->remote_attr_name << ") val=" << string(i2_2->value.begin(), i2_2->value.end()) << endl;
		try
		{
			if(i2_2->value.id() == formula_grammar::val_rID || i2_2->value.id() == formula_grammar::val_hID)
			{
				string val_d(i2_2->value.begin(), i2_2->value.end());
				//TODO: Tango types?
				Tango::DeviceData Din;
				Din << (Tango::DevDouble)strtod(val_d.c_str(), 0);
				it_ev->remote_device->command_inout(it_ev->remote_attr_name,Din);
			}
			else if(i2_2->value.id() == formula_grammar::val_stID)
			{
		        string val_st(i2_2->value.begin(), i2_2->value.end());

		        Tango::DevState st =  (Tango::DevState)i2_2->value.value();			//get value directly from node saved with access_node_d
				Tango::DeviceData Din;
				Din << st;
				it_ev->remote_device->command_inout(it_ev->remote_attr_name,Din);
			}
			else if(i2_2->value.id() == formula_grammar::val_stringID)
			{
		        string val_st(i2_2->value.begin()+1, i2_2->value.end()-1);//TODO: check string
				Tango::DeviceData Din;
				Din << val_st;
				it_ev->remote_device->command_inout(it_ev->remote_attr_name,Din);
			}
		}
		catch(Tango::DevFailed &e)
		{
        	err <<  "in node func_tangoID(" << string(i->value.begin(), i->value.end()) << ") write command_inout exception=" << e.errors[0].desc;
        	throw err.str();
		}
		value = 1;
		return;
	}
	else
	{
		stringstream tmp;
		for(int u=0; u<i->children.size(); u++)
			tmp << u<< "="<<string((i->children.begin()+u)->value.begin(), (i->children.begin()+u)->value.end()) << " ";
    	err <<  "in node func_tangoID(" << string(i->value.begin(), i->value.end()) << ") not executed! (wrong parameters) (children="<<i->children.size()<<"->)"<<tmp.str();
    	throw err.str();
	}
}


void SequencerConf::find_device_formula(tree_parse_info_t tree, vector<string> & devs)
{
    eval_node_device(tree.trees.begin(), devs);
    return;
}

void SequencerConf::eval_node_device(iter_t const& i, vector<string> & devs)
{
	/*DEBUG_STREAM << "In eval_node_device. i->value = " <<
        string(i->value.begin(), i->value.end()) <<
        " i->children.size() = " << i->children.size() << " NODE=" <<
        rule_names[i->value.id()] <<  endl;*/

    ostringstream err;
    err << "Looking for event in formula tree: ";
    /*if (i->value.id() == formula_grammar::event_ID)
    {
    	DEBUG_STREAM << "eval_node_device(): in eventID!!!=" << string(i->value.begin(), i->value.end()) << endl;
    }
    else*/ if (i->value.id() == formula_grammar::nameID)
    {
    	INFO_STREAM << "eval_node_device(): find event name=" << string(i->value.begin(), i->value.end()) << endl;
    	if(i->children.size() != 0)
		{
        	err <<  "in node nameID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
        	throw err.str();
        }
        string s(i->value.begin(), i->value.end());
        std::transform(s.begin(), s.end(), s.begin(), (int(*)(int))tolower);		//transform to lowercase
		devs.push_back(s);
    }
    //cout << endl;
    //iter_t it = i->children.begin();
    for(iter_t it = i->children.begin(); it != i->children.end(); it++)
    	eval_node_device(it, devs);
    return;
}

void SequencerConf::extract_values(Tango::DeviceAttribute *attr_value, vector<double> &val, vector<string> &val_string)
{
	Tango::DevState stval;
	vector<Tango::DevState> v_st;
	vector<Tango::DevULong> v_ulo;
	vector<Tango::DevUChar> v_uch;
	vector<Tango::DevShort> v_sh;
	vector<Tango::DevUShort> v_ush;
	vector<Tango::DevLong> v_lo;
	vector<Tango::DevDouble> v_do;
	vector<Tango::DevFloat> v_fl;
	vector<Tango::DevBoolean> v_bo;
	vector<Tango::DevLong64> v_lo64;
	vector<Tango::DevULong64> v_ulo64;
	//vector<string> v_string;

	val.clear();

	if (attr_value->get_type() == Tango::DEV_UCHAR)
	{
		attr_value->extract_read(v_uch);
		for(vector<Tango::DevUChar>::iterator it = v_uch.begin(); it != v_uch.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_SHORT)
	{
		attr_value->extract_read(v_sh);
		for(vector<Tango::DevShort>::iterator  it = v_sh.begin(); it != v_sh.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_USHORT)
	{
		attr_value->extract_read(v_ush);
		for(vector<Tango::DevUShort>::iterator  it = v_ush.begin(); it != v_ush.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_LONG)
	{
		attr_value->extract_read(v_lo);
		for(vector<Tango::DevLong>::iterator  it = v_lo.begin(); it != v_lo.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_LONG64)
	{
		attr_value->extract_read(v_lo64);
		for(vector<Tango::DevLong64>::iterator  it = v_lo64.begin(); it != v_lo64.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_STATE)
	{
		attr_value->extract_read(v_st);
		//TODO: why extract_read not working with State
		if(v_st.size() == 0)
		{
			*(attr_value) >> stval;
			v_st.push_back(stval);
			DEBUG_STREAM << __func__<<": DEV_STATE extracted single value="<<(int)stval;
		}
		for(vector<Tango::DevState>::iterator it = v_st.begin(); it != v_st.end(); it++)
		{
			val.push_back((double)(*it));		//convert all to double
		}
	}
	else if (attr_value->get_type() == Tango::DEV_ULONG)
	{
		attr_value->extract_read(v_ulo);
		for(vector<Tango::DevULong>::iterator  it = v_ulo.begin(); it != v_ulo.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_ULONG64)
	{
		attr_value->extract_read(v_ulo64);
		for(vector<Tango::DevULong64>::iterator  it = v_ulo64.begin(); it != v_ulo64.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_DOUBLE)
	{
		attr_value->extract_read(v_do);
		for(vector<Tango::DevDouble>::iterator  it = v_do.begin(); it != v_do.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_FLOAT)
	{
		attr_value->extract_read(v_fl);
		for(vector<Tango::DevFloat>::iterator  it = v_fl.begin(); it != v_fl.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_BOOLEAN)
	{
		attr_value->extract_read(v_bo);
		for(vector<Tango::DevBoolean>::iterator  it = v_bo.begin(); it != v_bo.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_STRING)
	{
		/*attr_value->extract_read(v_string);
		val_string = *(v_string.begin());*/
		attr_value->extract_read(val_string);
	}
	else
	{
		ostringstream o;
		o << "unknown type=" << (int)attr_value->get_type() << ends;
		throw o.str();
	}
}

void SequencerConf::extract_values(Tango::DeviceData *attr_value, vector<double> &val, vector<string> &val_string)
{
	Tango::DevState stval;
	vector<Tango::DevState> v_st;
	vector<Tango::DevULong> v_ulo;
	vector<Tango::DevUChar> v_uch;
	vector<Tango::DevShort> v_sh;
	vector<Tango::DevUShort> v_ush;
	vector<Tango::DevLong> v_lo;
	vector<Tango::DevDouble> v_do;
	vector<Tango::DevFloat> v_fl;
	vector<Tango::DevBoolean> v_bo;
	vector<Tango::DevLong64> v_lo64;
	vector<Tango::DevULong64> v_ulo64;
	//vector<string> v_string;

	val.clear();
	/*attr_value->reset_exceptions(Tango::DeviceData::isempty_flag); //disable is_empty exception
	if(attr_value->is_empty())
	{
		cout << __func__<<" is empty!!"<<endl;
		return;
	}*/

	if (attr_value->get_type() == Tango::DEV_UCHAR)
	{
		*(attr_value) >> v_uch;
		for(vector<Tango::DevUChar>::iterator it = v_uch.begin(); it != v_uch.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_SHORT)
	{
		*(attr_value) >> v_sh;
		for(vector<Tango::DevShort>::iterator  it = v_sh.begin(); it != v_sh.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_USHORT)
	{
		*(attr_value) >> v_ush;
		for(vector<Tango::DevUShort>::iterator  it = v_ush.begin(); it != v_ush.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_LONG)
	{
		*(attr_value) >> v_lo;
		for(vector<Tango::DevLong>::iterator  it = v_lo.begin(); it != v_lo.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_LONG64)
	{
		*(attr_value) >> v_lo64;
		for(vector<Tango::DevLong64>::iterator  it = v_lo64.begin(); it != v_lo64.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_STATE)
	{
		DEBUG_STREAM << __func__ << ": DEV_STATE!!";
		//*(attr_value) >> v_st;		//doesn't work in tango 5
		*(attr_value) >> stval;
		/*v_st.push_back(stval);
		for(vector<Tango::DevState>::iterator it = v_st.begin(); it != v_st.end(); it++)
			val.push_back((double)(*it));		//convert all to double*/
		val.push_back((double)(stval));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_ULONG)
	{
		*(attr_value) >> v_ulo;
		for(vector<Tango::DevULong>::iterator  it = v_ulo.begin(); it != v_ulo.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_ULONG64)
	{
		*(attr_value) >> v_ulo64;
		for(vector<Tango::DevULong64>::iterator  it = v_ulo64.begin(); it != v_ulo64.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_DOUBLE)
	{
		*(attr_value) >> v_do;
		for(vector<Tango::DevDouble>::iterator  it = v_do.begin(); it != v_do.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_FLOAT)
	{
		*(attr_value) >> v_fl;
		for(vector<Tango::DevFloat>::iterator  it = v_fl.begin(); it != v_fl.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	//TODO
/*	else if (attr_value->get_type() == Tango::DEV_BOOLEAN)
	{
		*(attr_value) >> v_bo;
		for(vector<Tango::DevBoolean>::iterator  it = v_bo.begin(); it != v_bo.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}*/
	else if (attr_value->get_type() == Tango::DEV_STRING)
	{
		DEBUG_STREAM << __func__ << ": DEV_STRING!! isnull="<<(attr_value->is_empty() ? "YES" : "NO");
		*(attr_value) >> val_string;	//TODO: NOT WORKING!!
		DEBUG_STREAM << __func__ << ": DEV_STRING exctracted size="<<val_string.size();
	}
	else
	{
		ostringstream o;
		o << "unknown type=" << (int)attr_value->get_type() << ends;
		DEBUG_STREAM << __func__ << ": exception: " << o.str();
		throw o.str();
	}
}

void SequencerConf::extract_set_values(Tango::DeviceAttribute *attr_value, vector<double> &val, string &val_string)
{
	//Tango::DevState stval;
	vector<Tango::DevState> v_st;
	vector<Tango::DevULong> v_ulo;
	vector<Tango::DevUChar> v_uch;
	vector<Tango::DevShort> v_sh;
	vector<Tango::DevUShort> v_ush;
	vector<Tango::DevLong> v_lo;
	vector<Tango::DevDouble> v_do;
	vector<Tango::DevFloat> v_fl;
	vector<Tango::DevBoolean> v_bo;
	vector<Tango::DevLong64> v_lo64;
	vector<Tango::DevULong64> v_ulo64;
	vector<string> v_string;

	val.clear();

	if (attr_value->get_type() == Tango::DEV_UCHAR)
	{
		attr_value->extract_set(v_uch);
		for(vector<Tango::DevUChar>::iterator it = v_uch.begin(); it != v_uch.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_SHORT)
	{
		attr_value->extract_set(v_sh);
		for(vector<Tango::DevShort>::iterator  it = v_sh.begin(); it != v_sh.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_USHORT)
	{
		attr_value->extract_set(v_ush);
		for(vector<Tango::DevUShort>::iterator  it = v_ush.begin(); it != v_ush.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_LONG)
	{
		attr_value->extract_set(v_lo);
		for(vector<Tango::DevLong>::iterator  it = v_lo.begin(); it != v_lo.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_LONG64)
	{
		attr_value->extract_set(v_lo64);
		for(vector<Tango::DevLong64>::iterator  it = v_lo64.begin(); it != v_lo64.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_STATE)
	{
		attr_value->extract_set(v_st);
		//*(attr_value) >> stval;
		//v_st.push_back(stval);
		for(vector<Tango::DevState>::iterator it = v_st.begin(); it != v_st.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_ULONG)
	{
		attr_value->extract_set(v_ulo);
		for(vector<Tango::DevULong>::iterator  it = v_ulo.begin(); it != v_ulo.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_ULONG64)
	{
		attr_value->extract_set(v_ulo64);
		for(vector<Tango::DevULong64>::iterator  it = v_ulo64.begin(); it != v_ulo64.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_DOUBLE)
	{
		attr_value->extract_set(v_do);
		for(vector<Tango::DevDouble>::iterator  it = v_do.begin(); it != v_do.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_FLOAT)
	{
		attr_value->extract_set(v_fl);
		for(vector<Tango::DevFloat>::iterator  it = v_fl.begin(); it != v_fl.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_BOOLEAN)
	{
		attr_value->extract_set(v_bo);
		for(vector<Tango::DevBoolean>::iterator  it = v_bo.begin(); it != v_bo.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_STRING)
	{
		attr_value->extract_set(v_string);
		val_string = *(v_string.begin());
	}
	else
	{
		ostringstream o;
		o << "unknown type=" << (int)attr_value->get_type() << ends;
		throw o.str();
	}
}

Tango::DeviceAttribute* SequencerConf::insert_values(Tango::AttributeInfoEx attr_info, string attr_name, vector<double> val, vector<string> val_string)
{
	int i=0;
	Tango::DevState st;
	vector<Tango::DevState> v_st;
	vector<Tango::DevULong> v_ulo;
	Tango::DevULong ulo;
	vector<Tango::DevULong64> v_ulo64;
	Tango::DevULong64 ulo64;
	vector<Tango::DevUChar> v_uch;
	Tango::DevUChar uch;
	vector<Tango::DevShort> v_sh;
	Tango::DevShort sh;
	vector<Tango::DevUShort> v_ush;
	Tango::DevUShort ush;
	vector<Tango::DevLong> v_lo;
	Tango::DevLong lo;
	vector<Tango::DevLong64> v_lo64;
	Tango::DevLong64 lo64;
	vector<Tango::DevDouble> v_do;
	Tango::DevDouble _do;
	vector<Tango::DevFloat> v_fl;
	Tango::DevFloat fl;
	vector<Tango::DevBoolean> v_bo;
	Tango::DevBoolean bo;
	vector<string> v_string;
	string _string;
	Tango::DeviceAttribute *din_value;

	if (attr_info.data_type == Tango::DEV_UCHAR)
	{
		if(attr_info.max_dim_x > 1)
		{
			for(vector<double>::iterator it = val.begin(); it != val.end() && i < attr_info.max_dim_x; it++, i++)
				v_uch.push_back((Tango::DevUChar)(*it));		//convert all from double
			din_value = new Tango::DeviceAttribute(attr_name,v_uch);
		}
		else
		{
			uch = (Tango::DevUChar)(*val.begin());
			din_value = new Tango::DeviceAttribute(attr_name,uch);
		}
	}
	else if (attr_info.data_type == Tango::DEV_SHORT)
	{
		if(attr_info.max_dim_x > 1)
		{
			for(vector<double>::iterator it = val.begin(); it != val.end() && i < attr_info.max_dim_x; it++, i++)
				v_sh.push_back((Tango::DevShort)(*it));		//convert all from double
			din_value = new Tango::DeviceAttribute(attr_name,v_sh);
		}
		else
		{
			sh = (Tango::DevShort)(*val.begin());
			din_value = new Tango::DeviceAttribute(attr_name,sh);
		}
	}
	else if (attr_info.data_type == Tango::DEV_USHORT)
	{
		if(attr_info.max_dim_x > 1)
		{
			for(vector<double>::iterator it = val.begin(); it != val.end() && i < attr_info.max_dim_x; it++, i++)
				v_ush.push_back((Tango::DevUShort)(*it));		//convert all from double
			din_value = new Tango::DeviceAttribute(attr_name,v_ush);
		}
		else
		{
			ush = (Tango::DevUShort)(*val.begin());
			din_value = new Tango::DeviceAttribute(attr_name,ush);
		}
	}
	else if (attr_info.data_type == Tango::DEV_LONG)
	{
		if(attr_info.max_dim_x > 1)
		{
			for(vector<double>::iterator it = val.begin(); it != val.end() && i < attr_info.max_dim_x; it++, i++)
				v_lo.push_back((Tango::DevLong)(*it));		//convert all from double
			din_value = new Tango::DeviceAttribute(attr_name,v_lo);
		}
		else
		{
			lo = (Tango::DevLong)(*val.begin());
			din_value = new Tango::DeviceAttribute(attr_name,lo);
		}
	}
	else if (attr_info.data_type == Tango::DEV_LONG64)
	{
		if(attr_info.max_dim_x > 1)
		{
			for(vector<double>::iterator it = val.begin(); it != val.end() && i < attr_info.max_dim_x; it++, i++)
				v_lo64.push_back((Tango::DevLong64)(*it));		//convert all from double
			din_value = new Tango::DeviceAttribute(attr_name,v_lo64);
		}
		else
		{
			lo64 = (Tango::DevLong64)(*val.begin());
			din_value = new Tango::DeviceAttribute(attr_name,lo64);
		}
	}
	else if (attr_info.data_type == Tango::DEV_STATE)
	{
		if(attr_info.max_dim_x > 1)
		{
			for(vector<double>::iterator it = val.begin(); it != val.end() && i < attr_info.max_dim_x; it++, i++)
				v_st.push_back((Tango::DevState)(*it));		//convert all from double
			din_value = new Tango::DeviceAttribute(attr_name,v_st);
		}
		else
		{
			st = (Tango::DevState)(*(val.begin()));
			din_value = new Tango::DeviceAttribute(attr_name,st);
		}
	}
	else if (attr_info.data_type == Tango::DEV_ULONG)
	{
		if(attr_info.max_dim_x > 1)
		{
			for(vector<double>::iterator it = val.begin(); it != val.end() && i < attr_info.max_dim_x; it++, i++)
				v_ulo.push_back((Tango::DevULong)(*it));		//convert all from double
			din_value = new Tango::DeviceAttribute(attr_name,v_ulo);
		}
		else
		{
			ulo = (Tango::DevULong)(*(val.begin()));
			din_value = new Tango::DeviceAttribute(attr_name,ulo);
		}
	}
	else if (attr_info.data_type == Tango::DEV_ULONG64)
	{
		if(attr_info.max_dim_x > 1)
		{
			for(vector<double>::iterator it = val.begin(); it != val.end() && i < attr_info.max_dim_x; it++, i++)
				v_ulo64.push_back((Tango::DevULong64)(*it));		//convert all from double
			din_value = new Tango::DeviceAttribute(attr_name,v_ulo64);
		}
		else
		{
			ulo64 = (Tango::DevULong64)(*(val.begin()));
			din_value = new Tango::DeviceAttribute(attr_name,ulo64);
		}
	}
	else if (attr_info.data_type == Tango::DEV_DOUBLE)
	{
		if(attr_info.max_dim_x > 1)
		{
			for(vector<double>::iterator it = val.begin(); it != val.end() && i < attr_info.max_dim_x; it++, i++)
			{
				v_do.push_back((Tango::DevDouble)(*it));		//convert all from double
			}
			din_value = new Tango::DeviceAttribute(attr_name,v_do);
		}
		else
		{
			_do = (Tango::DevDouble)(*(val.begin()));
			din_value = new Tango::DeviceAttribute(attr_name,_do);
		}
	}
	else if (attr_info.data_type == Tango::DEV_FLOAT)
	{
		if(attr_info.max_dim_x > 1)
		{
			for(vector<double>::iterator it = val.begin(); it != val.end() && i < attr_info.max_dim_x; it++, i++)
				v_fl.push_back((Tango::DevFloat)(*it));		//convert all from double
			din_value = new Tango::DeviceAttribute(attr_name,v_fl);
		}
		else
		{
			fl = (Tango::DevFloat)(*(val.begin()));
			din_value = new Tango::DeviceAttribute(attr_name,fl);
		}
	}
	else if (attr_info.data_type == Tango::DEV_BOOLEAN)
	{
		if(attr_info.max_dim_x > 1)
		{
			for(vector<double>::iterator it = val.begin(); it != val.end() && i < attr_info.max_dim_x; it++, i++)
				v_bo.push_back((Tango::DevBoolean)(*it));		//convert all from double
			din_value = new Tango::DeviceAttribute(attr_name,v_bo);
		}
		else
		{
			bo = (Tango::DevBoolean)(*(val.begin()));
			din_value = new Tango::DeviceAttribute(attr_name,bo);
		}
	}
	else if (attr_info.data_type == Tango::DEV_STRING)
	{
		if(attr_info.max_dim_x > 1)
		{
			for(vector<string>::iterator it = val_string.begin(); it != val_string.end() && i < attr_info.max_dim_x; it++, i++)
				v_string.push_back(*it);		//convert all from string
			din_value = new Tango::DeviceAttribute(attr_name,v_string);
		}
		else
		{
			_string = *(val_string.begin());
			din_value = new Tango::DeviceAttribute(attr_name,_string);
		}
	}
	else
	{
		ostringstream o;
		o << "unknown type=" << (int)attr_info.data_type << ends;
		throw o.str();
	}
	DEBUG_STREAM << __func__<<": exiting...";
	return din_value;
}

vector<remote_dev_t>::iterator SequencerConf::find_events(string event_name) throw(string&)
{
	//DEBUG_STREAM << __func__<<": entering... remote_devices.size()="<<remote_devices.size();
	vector<remote_dev_t>::iterator it_ev;
	std::transform(event_name.begin(), event_name.end(), event_name.begin(), (int(*)(int))tolower);		//transform to lowercase
	for(it_ev = remote_devices.begin(); it_ev != remote_devices.end(); it_ev++)
	{
		//DEBUG_STREAM << __func__<<": 1 looking for: '"<<event_name<<"' now remote_name: '"<<it_ev->remote_name<<"'";
		if(it_ev->remote_name.find(event_name) != string::npos)	//TODO: or ==
			return it_ev;
	}

	if (it_ev == remote_devices.end())
	{
		//try to remove network domain and FQDN
		string ev_name_str(event_name);
		string::size_type pos_slash = ev_name_str.find("tango://");
		if (pos_slash != string::npos)	//FQDN!!
		{
			//first remove network domain if any
			string::size_type pos_dot = ev_name_str.find(".",8);	//look for first . after tango://
			string::size_type pos_colon = ev_name_str.find(":",8);	//look for first : after tango://
			pos_slash = ev_name_str.find('/',8);					//look for first / after tango://
			if(pos_dot < pos_slash && pos_dot != string::npos && pos_colon != string::npos && pos_slash != string::npos)	//dot is in the TANGO_HOST part
			{
				string ev_name_str_no_domain = ev_name_str.substr(0,pos_dot) + ev_name_str.substr(pos_colon);
				for(it_ev = remote_devices.begin(); it_ev != remote_devices.end(); it_ev++)
				{
					//DEBUG_STREAM << __func__<<": 2 looking for: '"<<event_name<<"' now remote_name: '"<<it_ev->remote_name<<"'";
					if(it_ev->remote_name.find(ev_name_str_no_domain) != string::npos)	//TODO: or ==
						return it_ev;
				}
			}
			if (it_ev == remote_devices.end() && pos_slash != string::npos)
			{
				ev_name_str = ev_name_str.substr(pos_slash + 1);//remove FQDN
				for(it_ev = remote_devices.begin(); it_ev != remote_devices.end(); it_ev++)
				{
					//DEBUG_STREAM << __func__<<": 3 looking for: '"<<event_name<<"' now remote_name: '"<<it_ev->remote_name<<"'";
					if(it_ev->remote_name.find(ev_name_str) != string::npos)	//TODO: or ==
						return it_ev;
				}
			}
		}
		if (it_ev == remote_devices.end())
		{
			/*
			 * shouldn't happen!!!
			 */
			ostringstream o;
			o << "find_events(): event '" \
				<< event_name << "' not found!" << ends;
				ERROR_STREAM << o.str() << endl;
			//cerr << o.str() << endl;
			throw o.str();
		}
	}

	//if (it_ev != remote_devices.end())
	{
		return it_ev;
	}
}

//+------------------------------------------------------------------
//
//	method:			readthread::abort_sleep
//
//	description:	Resume from sleep if abort_flag set (sec.)
//
//-------------------------------------------------------------------
void SequencerConf::abort_sleep(double time)
{
	stringstream log;
	log << "Sleep("<<time<<")";
	add_log_str(log.str());
	for (int i = 0; i < (time/0.5); i++)
	{
		if (get_state() != Tango::RUNNING && get_state() != Tango::STANDBY)
			break;
		stringstream status;
		status<<"Running ("<<step<<"/"<<att_data.size()<<")(Sleeping("<<i*0.5<<"/"<<time<<"))";
		set_status(status.str());
		usleep(500000);
	}
}

//+------------------------------------------------------------------
//
//	method:			readthread::add_log_str
//
//	description:	add and update log_str array
//
//-------------------------------------------------------------------
void SequencerConf::add_log_str(string log)
{
	struct timeval now;
	gettimeofday(&now, NULL);
	for(int i=LOG_SIZE-1; i>=1; i--)
	{
		strcpy(log_str[i],log_str[i-1]);
	}
	sprintf(log_str[0],"%11.3f step%d: %s",now.tv_sec + (double)(now.tv_usec)/1000.0, step, log.c_str());
	if(log_str_size < LOG_SIZE)
		log_str_size++;
}

/***************************************************************************

  CmdClass class

***************************************************************************/
CORBA::Any *CmdClass::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout << "CmdClass::" << get_name() << ": entering..." << endl;

	return new CORBA::Any();

}

#if 0

/*
 * EventCallBack class methods
 */
EventCallBack::EventCallBack(void)
{
	//cout<<"EventCallBack::EventCallBack entering..."<<endl;
	mydevice = NULL;
	//mydevices.clear();
}

EventCallBack::~EventCallBack(void)
{
	//cout<<"EventCallBack::~EventCallBack entering..."<<endl;
	mydevice = NULL;
	//mydevices.clear();
}



void EventCallBack::push_event(Tango::EventData* ev)
{
	//cout<<"EventCallBack::push_event entering... event_name="<<ev->attr_name<<endl;
	string temp_name;
	string ev_name;
	Tango::DeviceAttribute attr_value;
	//vector<Tango::DevBoolean> value_b;

	//vector<SequencerConf *>::iterator it;
	//for(it = mydevices.begin(); it != mydevices.end(); it++)
	//{
	//	SequencerConf *mydevice = *it;

	vector<remote_dev_t>::iterator it_ev=mydevice->remote_devices.end();
	struct timeval now_log;
	gettimeofday(&now_log, NULL);

	try {
			it_ev=mydevice->find_events(ev->attr_name);
			if (!ev->err)
			{
				//e.ev_name = ev->attr_name;
				//e.ts = ev->attr_value->time;
				//vector<remote_dev_t>::iterator it_ev=find_events(ev->attr_name);
				//extract_values(ev->attr_value, e.value, e.type);
				if(it_ev != mydevice->remote_devices.end())
				{
					mydevice->extract_values(ev->attr_value, it_ev->value, it_ev->value_string);
					int k = it_ev->stat_index;
					clock_gettime(CLOCK_MONOTONIC,&it_ev->last_event_rx);
					double dnow = (double)(it_ev->last_event_rx.tv_sec) + ((double)it_ev->last_event_rx.tv_nsec)/1e9;
					if(k<3*MAX_ATTR_SIZE)
						sprintf(mydevice->log_str[k], "%s: %13.3f - EVENT '%s' OK", it_ev->remote_device_name.c_str(), dnow, it_ev->remote_attr_name.c_str());
					it_ev->event_error = false;

					//iterate through local attributes, evaluates formulas involved and push events
					for(vector<string>::iterator it_loc_attr=it_ev->loc_attr_name.begin(); it_loc_attr!=it_ev->loc_attr_name.end(); it_loc_attr++)
					{
						//cout<<(int)now_log.tv_sec<<" "<<__func__<<": event_name="<<ev->attr_name<<" evaluating loc attr: "<<*it_loc_attr<<endl;
						map<string,vector<attr_desc_t> >::iterator it_attr = mydevice->att_data.find(*it_loc_attr);
						map<string,attr_val_t >::iterator it_val = mydevice->att_value.find(*it_loc_attr);
						if(it_attr == mydevice->att_data.end() || it_val == mydevice->att_value.end())
							continue;

						bool formula_err = false;
						for(vector<attr_desc_t>::iterator it_rem_attr = it_attr->second.begin(); it_rem_attr != it_attr->second.end(); it_rem_attr++)
						{
							//cout <<(int)now_log.tv_sec<<" "<< __FUNCTION__ << " looping " << it_ev->formula<<endl;
							//cout<<(int)now_log.tv_sec<<" "<<"EventCallBack::push_event event_name="<<ev->attr_name<<" evaluating loc attr: "<<*it_loc_attr<<" evaluating formula: "<<it_rem_attr->formula<<endl;
							string attr_values;
							double res = 0.0;	//initialize to false
							try
							{
								res = mydevice->eval_formula(it_rem_attr->formula_tree, *it_loc_attr, attr_values);
							}
							catch(string &err)
							{
								cout <<(int)now_log.tv_sec<<" "<< __func__<<": error evaluating formula="<<it_rem_attr->formula<<" err="<<err<<endl;
								formula_err = true;
								break;
							}
							catch(std::out_of_range &err)
							{
								cout <<(int)now_log.tv_sec<<" "<< __func__<<": out_of_range exception evaluating formula="<<it_rem_attr->formula<<" err="<<err.what()<<endl;
								formula_err = true;
								break;
							}
							catch(...)
							{
								cout <<(int)now_log.tv_sec<<" "<< __func__<<": generic exception evaluating formula="<<it_rem_attr->formula<<endl;
								formula_err = true;
								break;
							}
							if(it_rem_attr->type == "bool")
							{
								it_val->second.val[ it_rem_attr->attr_index ] = (res != 0.0);
							}
							else if(it_rem_attr->type == "double")
							{
								it_val->second.val_d[ it_rem_attr->attr_index ] = res;
							}
							else if(it_rem_attr->type == "long")
							{
								it_val->second.val_l[ it_rem_attr->attr_index ] = (Tango::DevLong)round(res);
							}
							else
							{
								formula_err = true;
								break;
							}
						}
						//something went wrong-> skip this local attribute
						if(formula_err)
							continue;

					    //	Set the attribute value
					    //attr.set_value(&(it_val->second.val[0]), it_attr->second.size());
						bool changed = false;
						for(uint32_t i=0; i<it_attr->second.size(); i++)
						{
							if(it_attr->second[0].type == "bool")
							{
								if(it_val->second.val[ i ] != it_val->second.old_val[ i ])
									changed = true;
							}
							else if(it_attr->second[0].type == "double")
							{
								if(it_val->second.val_d[ i ] != it_val->second.old_val_d[ i ])
									changed = true;
							}
							else if(it_attr->second[0].type == "long")
							{
								if(it_val->second.val_l[ i ] != it_val->second.old_val_l[ i ])
									changed = true;
							}
						}

						if(changed || it_attr->second[0].first_push)
						{
							//cout<<(int)now_log.tv_sec<<" "<<"EventCallBack::push_event event_name="<<ev->attr_name<<" evaluating loc attr: "<<*it_loc_attr<<" CHANGED-> pushing changed="<<(int)changed<<" first_push="<<(int)it_attr->second[0].first_push<<endl;
							it_attr->second[0].first_push = false;
							bool push_err=false;
							try{
								if(it_attr->second[0].type == "bool")
									mydevice->push_change_event(*it_loc_attr,&(it_val->second.val[0]),/*NULL,Tango::ATTR_VALID,*/ it_attr->second.size(), 0, false);
								else if(it_attr->second[0].type == "double")
									mydevice->push_change_event(*it_loc_attr,&(it_val->second.val_d[0]),/*NULL,Tango::ATTR_VALID,*/ it_attr->second.size(), 0, false);
								else if(it_attr->second[0].type == "long")
									mydevice->push_change_event(*it_loc_attr,&(it_val->second.val_l[0]),/*NULL,Tango::ATTR_VALID,*/ it_attr->second.size(), 0, false);
							} catch(Tango::DevFailed &e)
							{
								cout <<(int)now_log.tv_sec<<" "<< "EventCallBack::push_event() error pushing change event="<<e.errors[0].desc<<endl;
								push_err=true;
							}
							if(!push_err)
							{
								for(uint32_t i=0; i<it_attr->second.size() && i<MAX_ATTR_SIZE; i++)
								{
									if(it_attr->second[0].type == "bool")
										it_val->second.old_val[ i ] = it_val->second.val[ i ];
									else if(it_attr->second[0].type == "double")
										it_val->second.old_val_d[ i ] = it_val->second.val_d[ i ];
									else if(it_attr->second[0].type == "long")
										it_val->second.old_val_l[ i ] = it_val->second.val_l[ i ];
								}
							}
						}
						else
						{
							//cout<<(int)now_log.tv_sec<<" "<<"EventCallBack::push_event event_name="<<ev->attr_name<<" evaluating loc attr: "<<*it_loc_attr<<" NOT CHANGED"<<endl;
						}
					}

				}
				else
				{
					cout <<(int)now_log.tv_sec<<" "<< __func__<<": event ok but event '"<<ev->attr_name<<"' not found!"<<endl;;
				}
			}
			else
			{
				temp_name = ev->attr_name + string(".") + ev->event;		//TODO: BUG IN TANGO: part of attr_name after first dot continues in field event

				size_t pos_change = temp_name.find(".change");
				if(pos_change != string::npos)
				{
					temp_name = temp_name.substr(0,pos_change);
				}
				ostringstream o;
				o << "Tango error for '" << temp_name << "'=" << ev->errors[0].desc.in() << ends;

				if(it_ev != mydevice->remote_devices.end())
				{
					int k = it_ev->stat_index;
					struct timespec now;
					clock_gettime(CLOCK_MONOTONIC,&now);
					double dnow = (double)(now.tv_sec) + ((double)now.tv_nsec)/1e9;
					string err(ev->errors[0].desc.in());
					if(k<3*MAX_ATTR_SIZE)
						sprintf(mydevice->log_str[k], "%s: %13.3f - EVENT '%s' ERROR: '%s'", it_ev->remote_device_name.c_str(), dnow, it_ev->remote_attr_name.c_str(), err.c_str());
					it_ev->event_error = true;
				}
				else
				{
					cout <<(int)now_log.tv_sec<<" "<< __func__<<": event error and event '"<<ev->attr_name<<"' not found!"<<endl;
				}
			}
		}
		catch (string &err) {
			//cout <<(int)now_log.tv_sec<<" "<< __func__<<": exception for '"<<ev->attr_name<<"' err="<<err<<endl;
			if(it_ev != mydevice->remote_devices.end())
			{
				int k = it_ev->stat_index;
				struct timespec now;
				clock_gettime(CLOCK_MONOTONIC,&now);
				double dnow = (double)(now.tv_sec) + ((double)now.tv_nsec)/1e9;
				if(k<3*MAX_ATTR_SIZE)
					sprintf(mydevice->log_str[k], "%s: %13.3f - EVENT '%s' ERROR: '%s'", it_ev->remote_device_name.c_str(), dnow, it_ev->remote_attr_name.c_str(), err.c_str());
				it_ev->event_error = true;
			}
			else
			{
				cout <<(int)now_log.tv_sec<<" "<< __func__<<": exception and event '"<<ev->attr_name<<"' not found! err="<<err<<endl;
			}

		} catch(Tango::DevFailed Terr)
		{
			if(it_ev != mydevice->remote_devices.end())
			{
				int k = it_ev->stat_index;
				struct timespec now;
				clock_gettime(CLOCK_MONOTONIC,&now);
				double dnow = (double)(now.tv_sec) + ((double)now.tv_nsec)/1e9;
				string err(Terr.errors[0].desc);
				if(k<3*MAX_ATTR_SIZE)
					sprintf(mydevice->log_str[k], "%s: %13.3f - EVENT '%s' ERROR: '%s'", it_ev->remote_device_name.c_str(), dnow, it_ev->remote_attr_name.c_str(), err.c_str());
				it_ev->event_error = true;
			}
			else
			{
				cout <<(int)now_log.tv_sec<<" "<< __func__<<": Tango exception and event '"<<ev->attr_name<<"' not found! err="<<Terr.errors[0].desc<<endl;
			}
		}
		catch (...) {
			if(it_ev != mydevice->remote_devices.end())
			{
				int k = it_ev->stat_index;
				struct timespec now;
				clock_gettime(CLOCK_MONOTONIC,&now);
				double dnow = (double)(now.tv_sec) + ((double)now.tv_nsec)/1e9;
				string err("Generic Event Exception");
				//if(k<3*MAX_ATTR_SIZE)
				//	sprintf(mydevice->log_str[k], "%s: %13.3f - EVENT '%s' ERROR: '%s'", it_ev->remote_device_name.c_str(), dnow, it_ev->remote_attr_name.c_str(), err.c_str());
				it_ev->event_error = true;
			}
			else
			{
				cout <<(int)now_log.tv_sec<<" "<< __func__<<": generic exception and event '"<<ev->attr_name<<"' not found!"<<endl;
			}
		}
	//}
}  /* push_event() */

void EventCallBack::init(SequencerConf *p)
{
	//cout<<(int)now_log.tv_sec<<" "<<"EventCallBack::init entering..."<<endl;
	mydevice = p;
	//mydevices.push_back(p);
}

#endif

	/*----- PROTECTED REGION END -----*/	//	SequencerConf::namespace_ending
} //	namespace
